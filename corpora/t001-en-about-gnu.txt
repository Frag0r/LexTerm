https://www.gnu.org/gnu/about-gnu.html
About the GNU Operating System
The name “GNU” is a recursive acronym for “GNU's Not Unix!”; it is pronounced as one syllable with a hard g.

[Other historical and general articles about GNU.]

GNU was launched by Richard Stallman (rms) in 1983, as an operating system which would be put together by people working together for the freedom of all software users to control their computing. rms remains the Chief GNUisance today.

The primary and continuing goal of GNU is to offer a Unix-compatible system that would be 100% free software. Not 95% free, not 99.5%, but 100%. The name of the system, GNU, is a recursive acronym meaning GNU's Not Unix—a way of paying tribute to the technical ideas of Unix, while at the same time saying that GNU is something different. Technically, GNU is like Unix. But unlike Unix, GNU gives its users freedom.

Completely free system distributions (“distros”) meeting this goal are available today, many using the Linux-libre kernel (the relationship between GNU and the Linux kernel is described more fully elsewhere). The GNU packages have been designed to work together so we could have a functioning GNU system. It has turned out that they also serve as a common “upstream” for many distros, so contributions to GNU packages help the free software community as a whole. Naturally, work on GNU is ongoing, with the goal to create a system that gives the greatest freedom to computer users. GNU packages include user-oriented applications, utilities, tools, libraries, even games—all the programs that an operating system can usefully offer to its users. New packages are welcome.

Thousands of people have joined in to make GNU the success it is today, and there are many ways to contribute, both technical and non-technical. GNU developers gather from time to time in GNU Hackers Meetings, sometimes as part of the larger free software community LibrePlanet conferences.

GNU has been supported in several ways by the Free Software Foundation, the nonprofit organization also founded by rms to advocate free software ideals. Among other things, the FSF accepts copyright assignments and disclaimers, so it can act in court on behalf of GNU programs. (To be clear, contributing a program to GNU does not require transferring copyright to the FSF. If you do assign copyright, the FSF will enforce the GPL for the program if someone violates it; if you keep the copyright, enforcement will be up to you.)

The ultimate goal is to provide free software to do all of the jobs computer users want to do—and thus make proprietary software a thing of the past.


https://www.gnu.org/gnu/gnu-history.html
Overview of the GNU System
The GNU operating system is a complete free software system, upward-compatible with Unix. GNU stands for “GNU's Not Unix”. It is pronounced as one syllable with a hard g. Richard Stallman made the Initial Announcement of the GNU Project in September 1983. A longer version called the GNU Manifesto was published in March 1985. It has been translated into several other languages.

The name “GNU” was chosen because it met a few requirements; first, it was a recursive acronym for “GNU's Not Unix”, second, because it was a real word, and third, it was fun to say (or Sing).

The word “free” in “free software” pertains to freedom, not price. You may or may not pay a price to get GNU software. Either way, once you have the software you have four specific freedoms in using it. The freedom to run the program as you wish; the freedom to copy the program and give it away to your friends and co-workers; the freedom to change the program as you wish, by having full access to source code; the freedom to distribute an improved version and thus help build the community. (If you redistribute GNU software, you may charge a fee for the physical act of transferring a copy, or you may give away copies.)

The project to develop the GNU system is called the “GNU Project”. The GNU Project was conceived in 1983 as a way of bringing back the cooperative spirit that prevailed in the computing community in earlier days—to make cooperation possible once again by removing the obstacles to cooperation imposed by the owners of proprietary software.

In 1971, when Richard Stallman started his career at MIT, he worked in a group which used free software exclusively. Even computer companies often distributed free software. Programmers were free to cooperate with each other, and often did.

By the 1980s, almost all software was proprietary, which means that it had owners who forbid and prevent cooperation by users. This made the GNU Project necessary.

Every computer user needs an operating system; if there is no free operating system, then you can't even get started using a computer without resorting to proprietary software. So the first item on the free software agenda obviously had to be a free operating system.

We decided to make the operating system compatible with Unix because the overall design was already proven and portable, and because compatibility makes it easy for Unix users to switch from Unix to GNU.

A Unix-like operating system includes a kernel, compilers, editors, text formatters, mail software, graphical interfaces, libraries, games and many other things. Thus, writing a whole operating system is a very large job. We started in January 1984. The Free Software Foundation was founded in October 1985, initially to raise funds to help develop GNU.

By 1990 we had either found or written all the major components except one—the kernel. Then Linux, a Unix-like kernel, was developed by Linus Torvalds in 1991 and made free software in 1992. Combining Linux with the almost-complete GNU system resulted in a complete operating system: the GNU/Linux system. Estimates are that tens of millions of people now use GNU/Linux systems, typically via GNU/Linux distributions. The principal version of Linux now contains non-free firmware “blobs”; free software activists now maintain a modified free version of Linux, called Linux-libre.

However, the GNU Project is not limited to the core operating system. We aim to provide a whole spectrum of software, whatever many users want to have. This includes application software. See the Free Software Directory for a catalogue of free software application programs.

We also want to provide software for users who are not computer experts. Therefore we developed a graphical desktop (called GNOME) to help beginners use the GNU system.

We also want to provide games and other recreations. Plenty of free games are already available.

How far can free software go? There are no limits, except when laws such as the patent system prohibit free software. The ultimate goal is to provide free software to do all of the jobs computer users want to do—and thus make proprietary software a thing of the past.


https://www.gnu.org/gnu/thegnuproject.html
The GNU Project
by Richard Stallman

Originally published in the book Open Sources. Richard Stallman was never a supporter of “open source”, but contributed this article so that the ideas of the free software movement would not be entirely absent from that book.

Why it is even more important than ever to insist that the software we use be free.

The first software-sharing community
When I started working at the MIT Artificial Intelligence Lab in 1971, I became part of a software-sharing community that had existed for many years. Sharing of software was not limited to our particular community; it is as old as computers, just as sharing of recipes is as old as cooking. But we did it more than most.

The AI Lab used a timesharing operating system called ITS (the Incompatible Timesharing System) that the lab's staff hackers (1) had designed and written in assembler language for the Digital PDP-10, one of the large computers of the era. As a member of this community, an AI Lab staff system hacker, my job was to improve this system.

We did not call our software “free software”, because that term did not yet exist; but that is what it was. Whenever people from another university or a company wanted to port and use a program, we gladly let them. If you saw someone using an unfamiliar and interesting program, you could always ask to see the source code, so that you could read it, change it, or cannibalize parts of it to make a new program.

(1) The use of “hacker” to mean “security breaker” is a confusion on the part of the mass media. We hackers refuse to recognize that meaning, and continue using the word to mean someone who loves to program, someone who enjoys playful cleverness, or the combination of the two. See my article, On Hacking.

The collapse of the community
The situation changed drastically in the early 1980s when Digital discontinued the PDP-10 series. Its architecture, elegant and powerful in the 60s, could not extend naturally to the larger address spaces that were becoming feasible in the 80s. This meant that nearly all of the programs composing ITS were obsolete.

The AI Lab hacker community had already collapsed, not long before. In 1981, the spin-off company Symbolics had hired away nearly all of the hackers from the AI Lab, and the depopulated community was unable to maintain itself. (The book Hackers, by Steve Levy, describes these events, as well as giving a clear picture of this community in its prime.) When the AI Lab bought a new PDP-10 in 1982, its administrators decided to use Digital's nonfree timesharing system instead of ITS.

The modern computers of the era, such as the VAX or the 68020, had their own operating systems, but none of them were free software: you had to sign a nondisclosure agreement even to get an executable copy.

This meant that the first step in using a computer was to promise not to help your neighbor. A cooperating community was forbidden. The rule made by the owners of proprietary software was, “If you share with your neighbor, you are a pirate. If you want any changes, beg us to make them.”

The idea that the proprietary software social system—the system that says you are not allowed to share or change software—is antisocial, that it is unethical, that it is simply wrong, may come as a surprise to some readers. But what else could we say about a system based on dividing the public and keeping users helpless? Readers who find the idea surprising may have taken the proprietary software social system as a given, or judged it on the terms suggested by proprietary software businesses. Software publishers have worked long and hard to convince people that there is only one way to look at the issue.

When software publishers talk about “enforcing” their “rights” or “stopping piracy”, what they actually say is secondary. The real message of these statements is in the unstated assumptions they take for granted, which the public is asked to accept without examination. Let's therefore examine them.

One assumption is that software companies have an unquestionable natural right to own software and thus have power over all its users. (If this were a natural right, then no matter how much harm it does to the public, we could not object.) Interestingly, the US Constitution and legal tradition reject this view; copyright is not a natural right, but an artificial government-imposed monopoly that limits the users' natural right to copy.

Another unstated assumption is that the only important thing about software is what jobs it allows you to do—that we computer users should not care what kind of society we are allowed to have.

A third assumption is that we would have no usable software (or would never have a program to do this or that particular job) if we did not offer a company power over the users of the program. This assumption may have seemed plausible, before the free software movement demonstrated that we can make plenty of useful software without putting chains on it.

If we decline to accept these assumptions, and judge these issues based on ordinary commonsense morality while placing the users first, we arrive at very different conclusions. Computer users should be free to modify programs to fit their needs, and free to share software, because helping other people is the basis of society.

There is no room here for an extensive statement of the reasoning behind this conclusion, so I refer the reader to the web pages http://www.gnu.org/philosophy/why-free.html and http://www.gnu.org/philosophy/free-software-even-more-important.html.

A stark moral choice
With my community gone, to continue as before was impossible. Instead, I faced a stark moral choice.

The easy choice was to join the proprietary software world, signing nondisclosure agreements and promising not to help my fellow hacker. Most likely I would also be developing software that was released under nondisclosure agreements, thus adding to the pressure on other people to betray their fellows too.

I could have made money this way, and perhaps amused myself writing code. But I knew that at the end of my career, I would look back on years of building walls to divide people, and feel I had spent my life making the world a worse place.

I had already experienced being on the receiving end of a nondisclosure agreement, when someone refused to give me and the MIT AI Lab the source code for the control program for our printer. (The lack of certain features in this program made use of the printer extremely frustrating.) So I could not tell myself that nondisclosure agreements were innocent. I was very angry when he refused to share with us; I could not turn around and do the same thing to everyone else.

Another choice, straightforward but unpleasant, was to leave the computer field. That way my skills would not be misused, but they would still be wasted. I would not be culpable for dividing and restricting computer users, but it would happen nonetheless.

So I looked for a way that a programmer could do something for the good. I asked myself, was there a program or programs that I could write, so as to make a community possible once again?

The answer was clear: what was needed first was an operating system. That is the crucial software for starting to use a computer. With an operating system, you can do many things; without one, you cannot run the computer at all. With a free operating system, we could again have a community of cooperating hackers—and invite anyone to join. And anyone would be able to use a computer without starting out by conspiring to deprive his or her friends.

As an operating system developer, I had the right skills for this job. So even though I could not take success for granted, I realized that I was elected to do the job. I chose to make the system compatible with Unix so that it would be portable, and so that Unix users could easily switch to it. The name GNU was chosen, following a hacker tradition, as a recursive acronym for “GNU's Not Unix.” It is pronounced as one syllable with a hard g.

An operating system does not mean just a kernel, barely enough to run other programs. In the 1970s, every operating system worthy of the name included command processors, assemblers, compilers, interpreters, debuggers, text editors, mailers, and much more. ITS had them, Multics had them, VMS had them, and Unix had them. The GNU operating system would include them too.

Later I heard these words, attributed to Hillel (1):

If I am not for myself, who will be for me?
If I am only for myself, what am I?
If not now, when?

The decision to start the GNU Project was based on a similar spirit.

(1) As an Atheist, I don't follow any religious leaders, but I sometimes find I admire something one of them has said.

Free as in freedom
The term “free software” is sometimes misunderstood—it has nothing to do with price. It is about freedom. Here, therefore, is the definition of free software.

A program is free software, for you, a particular user, if:

You have the freedom to run the program as you wish, for any purpose.
You have the freedom to modify the program to suit your needs. (To make this freedom effective in practice, you must have access to the source code, since making changes in a program without having the source code is exceedingly difficult.)
You have the freedom to redistribute copies, either gratis or for a fee.
You have the freedom to distribute modified versions of the program, so that the community can benefit from your improvements.
Since “free” refers to freedom, not to price, there is no contradiction between selling copies and free software. In fact, the freedom to sell copies is crucial: collections of free software sold on CD-ROMs are important for the community, and selling them is an important way to raise funds for free software development. Therefore, a program which people are not free to include on these collections is not free software.

Because of the ambiguity of “free”, people have long looked for alternatives, but no one has found a better term. The English language has more words and nuances than any other, but it lacks a simple, unambiguous, word that means “free”, as in freedom—“unfettered” being the word that comes closest in meaning. Such alternatives as “liberated”, “freedom”, and “open” have either the wrong meaning or some other disadvantage.

GNU software and the GNU system
Developing a whole system is a very large project. To bring it into reach, I decided to adapt and use existing pieces of free software wherever that was possible. For example, I decided at the very beginning to use TeX as the principal text formatter; a few years later, I decided to use the X Window System rather than writing another window system for GNU.

Because of these decisions, and others like them, the GNU system is not the same as the collection of all GNU software. The GNU system includes programs that are not GNU software, programs that were developed by other people and projects for their own purposes, but which we can use because they are free software.

Commencing the project
In January 1984 I quit my job at MIT and began writing GNU software. Leaving MIT was necessary so that MIT would not be able to interfere with distributing GNU as free software. If I had remained on the staff, MIT could have claimed to own the work, and could have imposed their own distribution terms, or even turned the work into a proprietary software package. I had no intention of doing a large amount of work only to see it become useless for its intended purpose: creating a new software-sharing community.

However, Professor Winston, then the head of the MIT AI Lab, kindly invited me to keep using the lab's facilities.

The first steps
Shortly before beginning the GNU Project, I heard about the Free University Compiler Kit, also known as VUCK. (The Dutch word for “free” is written with a v.) This was a compiler designed to handle multiple languages, including C and Pascal, and to support multiple target machines. I wrote to its author asking if GNU could use it.

He responded derisively, stating that the university was free but the compiler was not. I therefore decided that my first program for the GNU Project would be a multilanguage, multiplatform compiler.

Hoping to avoid the need to write the whole compiler myself, I obtained the source code for the Pastel compiler, which was a multiplatform compiler developed at Lawrence Livermore Lab. It supported, and was written in, an extended version of Pascal, designed to be a system-programming language. I added a C front end, and began porting it to the Motorola 68000 computer. But I had to give that up when I discovered that the compiler needed many megabytes of stack space, and the available 68000 Unix system would only allow 64k.

I then realized that the Pastel compiler functioned by parsing the entire input file into a syntax tree, converting the whole syntax tree into a chain of “instructions”, and then generating the whole output file, without ever freeing any storage. At this point, I concluded I would have to write a new compiler from scratch. That new compiler is now known as GCC; none of the Pastel compiler is used in it, but I managed to adapt and use the C front end that I had written. But that was some years later; first, I worked on GNU Emacs.

GNU Emacs
I began work on GNU Emacs in September 1984, and in early 1985 it was beginning to be usable. This enabled me to begin using Unix systems to do editing; having no interest in learning to use vi or ed, I had done my editing on other kinds of machines until then.

At this point, people began wanting to use GNU Emacs, which raised the question of how to distribute it. Of course, I put it on the anonymous ftp server on the MIT computer that I used. (This computer, prep.ai.mit.edu, thus became the principal GNU ftp distribution site; when it was decommissioned a few years later, we transferred the name to our new ftp server.) But at that time, many of the interested people were not on the Internet and could not get a copy by ftp. So the question was, what would I say to them?

I could have said, “Find a friend who is on the net and who will make a copy for you.” Or I could have done what I did with the original PDP-10 Emacs: tell them, “Mail me a tape and a SASE, and I will mail it back with Emacs on it.” But I had no job, and I was looking for ways to make money from free software. So I announced that I would mail a tape to whoever wanted one, for a fee of $150. In this way, I started a free software distribution business, the precursor of the companies that today distribute entire GNU/Linux system distributions.

Is a program free for every user?
If a program is free software when it leaves the hands of its author, this does not necessarily mean it will be free software for everyone who has a copy of it. For example, public domain software (software that is not copyrighted) is free software; but anyone can make a proprietary modified version of it. Likewise, many free programs are copyrighted but distributed under simple permissive licenses which allow proprietary modified versions.

The paradigmatic example of this problem is the X Window System. Developed at MIT, and released as free software with a permissive license, it was soon adopted by various computer companies. They added X to their proprietary Unix systems, in binary form only, and covered by the same nondisclosure agreement. These copies of X were no more free software than Unix was.

The developers of the X Window System did not consider this a problem—they expected and intended this to happen. Their goal was not freedom, just “success”, defined as “having many users.” They did not care whether these users had freedom, only that they should be numerous.

This led to a paradoxical situation where two different ways of counting the amount of freedom gave different answers to the question, “Is this program free?” If you judged based on the freedom provided by the distribution terms of the MIT release, you would say that X was free software. But if you measured the freedom of the average user of X, you would have to say it was proprietary software. Most X users were running the proprietary versions that came with Unix systems, not the free version.

Copyleft and the GNU GPL
The goal of GNU was to give users freedom, not just to be popular. So we needed to use distribution terms that would prevent GNU software from being turned into proprietary software. The method we use is called “copyleft”.(1)

Copyleft uses copyright law, but flips it over to serve the opposite of its usual purpose: instead of a means for restricting a program, it becomes a means for keeping the program free.

The central idea of copyleft is that we give everyone permission to run the program, copy the program, modify the program, and distribute modified versions—but not permission to add restrictions of their own. Thus, the crucial freedoms that define “free software” are guaranteed to everyone who has a copy; they become inalienable rights.

For an effective copyleft, modified versions must also be free. This ensures that work based on ours becomes available to our community if it is published. When programmers who have jobs as programmers volunteer to improve GNU software, it is copyleft that prevents their employers from saying, “You can't share those changes, because we are going to use them to make our proprietary version of the program.”

The requirement that changes must be free is essential if we want to ensure freedom for every user of the program. The companies that privatized the X Window System usually made some changes to port it to their systems and hardware. These changes were small compared with the great extent of X, but they were not trivial. If making changes were an excuse to deny the users freedom, it would be easy for anyone to take advantage of the excuse.

A related issue concerns combining a free program with nonfree code. Such a combination would inevitably be nonfree; whichever freedoms are lacking for the nonfree part would be lacking for the whole as well. To permit such combinations would open a hole big enough to sink a ship. Therefore, a crucial requirement for copyleft is to plug this hole: anything added to or combined with a copylefted program must be such that the larger combined version is also free and copylefted.

The specific implementation of copyleft that we use for most GNU software is the GNU General Public License, or GNU GPL for short. We have other kinds of copyleft that are used in specific circumstances. GNU manuals are copylefted also, but use a much simpler kind of copyleft, because the complexity of the GNU GPL is not necessary for manuals.(2)

(1) In 1984 or 1985, Don Hopkins (a very imaginative fellow) mailed me a letter. On the envelope he had written several amusing sayings, including this one: “Copyleft—all rights reversed.” I used the word “copyleft” to name the distribution concept I was developing at the time.

(2) We now use the GNU Free Documentation License for documentation.

The Free Software Foundation
As interest in using Emacs was growing, other people became involved in the GNU project, and we decided that it was time to seek funding once again. So in 1985 we created the Free Software Foundation (FSF), a tax-exempt charity for free software development. The FSF also took over the Emacs tape distribution business; later it extended this by adding other free software (both GNU and non-GNU) to the tape, and by selling free manuals as well.

Most of the FSF's income used to come from sales of copies of free software and of other related services (CD-ROMs of source code, CD-ROMs with binaries, nicely printed manuals, all with the freedom to redistribute and modify), and Deluxe Distributions (distributions for which we built the whole collection of software for the customer's choice of platform). Today the FSF still sells manuals and other gear, but it gets the bulk of its funding from members' dues. You can join the FSF at fsf.org.

Free Software Foundation employees have written and maintained a number of GNU software packages. Two notable ones are the C library and the shell. The GNU C library is what every program running on a GNU/Linux system uses to communicate with Linux. It was developed by a member of the Free Software Foundation staff, Roland McGrath. The shell used on most GNU/Linux systems is BASH, the Bourne Again Shell(1), which was developed by FSF employee Brian Fox.

We funded development of these programs because the GNU Project was not just about tools or a development environment. Our goal was a complete operating system, and these programs were needed for that goal.

(1) “Bourne Again Shell” is a play on the name “Bourne Shell”, which was the usual shell on Unix.

Free software support
The free software philosophy rejects a specific widespread business practice, but it is not against business. When businesses respect the users' freedom, we wish them success.

Selling copies of Emacs demonstrates one kind of free software business. When the FSF took over that business, I needed another way to make a living. I found it in selling services relating to the free software I had developed. This included teaching, for subjects such as how to program GNU Emacs and how to customize GCC, and software development, mostly porting GCC to new platforms.

Today each of these kinds of free software business is practiced by a number of corporations. Some distribute free software collections on CD-ROM; others sell support at levels ranging from answering user questions, to fixing bugs, to adding major new features. We are even beginning to see free software companies based on launching new free software products.

Watch out, though—a number of companies that associate themselves with the term “open source” actually base their business on nonfree software that works with free software. These are not free software companies, they are proprietary software companies whose products tempt users away from freedom. They call these programs “value-added packages”, which shows the values they would like us to adopt: convenience above freedom. If we value freedom more, we should call them “freedom-subtracted” packages.

Technical goals
The principal goal of GNU is to be free software. Even if GNU had no technical advantage over Unix, it would have a social advantage, allowing users to cooperate, and an ethical advantage, respecting the user's freedom.

But it was natural to apply the known standards of good practice to the work—for example, dynamically allocating data structures to avoid arbitrary fixed size limits, and handling all the possible 8-bit codes wherever that made sense.

In addition, we rejected the Unix focus on small memory size, by deciding not to support 16-bit machines (it was clear that 32-bit machines would be the norm by the time the GNU system was finished), and to make no effort to reduce memory usage unless it exceeded a megabyte. In programs for which handling very large files was not crucial, we encouraged programmers to read an entire input file into core, then scan its contents without having to worry about I/O.

These decisions enabled many GNU programs to surpass their Unix counterparts in reliability and speed.

Donated computers
As the GNU Project's reputation grew, people began offering to donate machines running Unix to the project. These were very useful, because the easiest way to develop components of GNU was to do it on a Unix system, and replace the components of that system one by one. But they raised an ethical issue: whether it was right for us to have a copy of Unix at all.

Unix was (and is) proprietary software, and the GNU Project's philosophy said that we should not use proprietary software. But, applying the same reasoning that leads to the conclusion that violence in self defense is justified, I concluded that it was legitimate to use a proprietary package when that was crucial for developing a free replacement that would help others stop using the proprietary package.

But, even if this was a justifiable evil, it was still an evil. Today we no longer have any copies of Unix, because we have replaced them with free operating systems. If we could not replace a machine's operating system with a free one, we replaced the machine instead.

The GNU Task List
As the GNU Project proceeded, and increasing numbers of system components were found or developed, eventually it became useful to make a list of the remaining gaps. We used it to recruit developers to write the missing pieces. This list became known as the GNU Task List. In addition to missing Unix components, we listed various other useful software and documentation projects that, we thought, a truly complete system ought to have.

Today (1), hardly any Unix components are left in the GNU Task List—those jobs had been done, aside from a few inessential ones. But the list is full of projects that some might call “applications”. Any program that appeals to more than a narrow class of users would be a useful thing to add to an operating system.

Even games are included in the task list—and have been since the beginning. Unix included games, so naturally GNU should too. But compatibility was not an issue for games, so we did not follow the list of games that Unix had. Instead, we listed a spectrum of different kinds of games that users might like.

(1) That was written in 1998. In 2009 we no longer maintain a long task list. The community develops free software so fast that we can't even keep track of it all. Instead, we have a list of High Priority Projects, a much shorter list of projects we really want to encourage people to write.

The GNU Library GPL
The GNU C library uses a special kind of copyleft called the GNU Library General Public License(1), which gives permission to link proprietary software with the library. Why make this exception?

It is not a matter of principle; there is no principle that says proprietary software products are entitled to include our code. (Why contribute to a project predicated on refusing to share with us?) Using the LGPL for the C library, or for any library, is a matter of strategy.

The C library does a generic job; every proprietary system or compiler comes with a C library. Therefore, to make our C library available only to free software would not have given free software any advantage—it would only have discouraged use of our library.

One system is an exception to this: on the GNU system (and this includes GNU/Linux), the GNU C library is the only C library. So the distribution terms of the GNU C library determine whether it is possible to compile a proprietary program for the GNU system. There is no ethical reason to allow proprietary applications on the GNU system, but strategically it seems that disallowing them would do more to discourage use of the GNU system than to encourage development of free applications. That is why using the Library GPL is a good strategy for the C library.

For other libraries, the strategic decision needs to be considered on a case-by-case basis. When a library does a special job that can help write certain kinds of programs, then releasing it under the GPL, limiting it to free programs only, is a way of helping other free software developers, giving them an advantage against proprietary software.

Consider GNU Readline, a library that was developed to provide command-line editing for BASH. Readline is released under the ordinary GNU GPL, not the Library GPL. This probably does reduce the amount Readline is used, but that is no loss for us. Meanwhile, at least one useful application has been made free software specifically so it could use Readline, and that is a real gain for the community.

Proprietary software developers have the advantages money provides; free software developers need to make advantages for each other. I hope some day we will have a large collection of GPL-covered libraries that have no parallel available to proprietary software, providing useful modules to serve as building blocks in new free software, and adding up to a major advantage for further free software development.

(1) This license is now called the GNU Lesser General Public License, to avoid giving the idea that all libraries ought to use it. See Why you shouldn't use the Lesser GPL for your next library for more information.

Scratching an itch?
Eric Raymond says that “Every good work of software starts by scratching a developer's personal itch.” Maybe that happens sometimes, but many essential pieces of GNU software were developed in order to have a complete free operating system. They come from a vision and a plan, not from impulse.

For example, we developed the GNU C library because a Unix-like system needs a C library, BASH because a Unix-like system needs a shell, and GNU tar because a Unix-like system needs a tar program. The same is true for my own programs—the GNU C compiler, GNU Emacs, GDB and GNU Make.

Some GNU programs were developed to cope with specific threats to our freedom. Thus, we developed gzip to replace the Compress program, which had been lost to the community because of the LZW patents. We found people to develop LessTif, and more recently started GNOME and Harmony, to address the problems caused by certain proprietary libraries (see below). We are developing the GNU Privacy Guard to replace popular nonfree encryption software, because users should not have to choose between privacy and freedom.

Of course, the people writing these programs became interested in the work, and many features were added to them by various people for the sake of their own needs and interests. But that is not why the programs exist.

Unexpected developments
At the beginning of the GNU Project, I imagined that we would develop the whole GNU system, then release it as a whole. That is not how it happened.

Since each component of the GNU system was implemented on a Unix system, each component could run on Unix systems long before a complete GNU system existed. Some of these programs became popular, and users began extending them and porting them—to the various incompatible versions of Unix, and sometimes to other systems as well.

The process made these programs much more powerful, and attracted both funds and contributors to the GNU Project. But it probably also delayed completion of a minimal working system by several years, as GNU developers' time was put into maintaining these ports and adding features to the existing components, rather than moving on to write one missing component after another.

The GNU Hurd
By 1990, the GNU system was almost complete; the only major missing component was the kernel. We had decided to implement our kernel as a collection of server processes running on top of Mach. Mach is a microkernel developed at Carnegie Mellon University and then at the University of Utah; the GNU Hurd is a collection of servers (i.e., a herd of GNUs) that run on top of Mach, and do the various jobs of the Unix kernel. The start of development was delayed as we waited for Mach to be released as free software, as had been promised.

One reason for choosing this design was to avoid what seemed to be the hardest part of the job: debugging a kernel program without a source-level debugger to do it with. This part of the job had been done already, in Mach, and we expected to debug the Hurd servers as user programs, with GDB. But it took a long time to make that possible, and the multithreaded servers that send messages to each other have turned out to be very hard to debug. Making the Hurd work solidly has stretched on for many years.

Alix
The GNU kernel was not originally supposed to be called the Hurd. Its original name was Alix—named after the woman who was my sweetheart at the time. She, a Unix system administrator, had pointed out how her name would fit a common naming pattern for Unix system versions; as a joke, she told her friends, “Someone should name a kernel after me.” I said nothing, but decided to surprise her with a kernel named Alix.

It did not stay that way. Michael (now Thomas) Bushnell, the main developer of the kernel, preferred the name Hurd, and redefined Alix to refer to a certain part of the kernel—the part that would trap system calls and handle them by sending messages to Hurd servers.

Later, Alix and I broke up, and she changed her name; independently, the Hurd design was changed so that the C library would send messages directly to servers, and this made the Alix component disappear from the design.

But before these things happened, a friend of hers came across the name Alix in the Hurd source code, and mentioned it to her. So she did have the chance to find a kernel named after her.

Linux and GNU/Linux
The GNU Hurd is not suitable for production use, and we don't know if it ever will be. The capability-based design has problems that result directly from the flexibility of the design, and it is not clear whether solutions exist.

Fortunately, another kernel is available. In 1991, Linus Torvalds developed a Unix-compatible kernel and called it Linux. It was proprietary at first, but in 1992, he made it free software; combining Linux with the not-quite-complete GNU system resulted in a complete free operating system. (Combining them was a substantial job in itself, of course.) It is due to Linux that we can actually run a version of the GNU system today.

We call this system version GNU/Linux, to express its composition as a combination of the GNU system with Linux as the kernel. Please don't fall into the practice of calling the whole system “Linux”, since that means attributing our work to someone else. Please give us equal mention.

Challenges in our future
We have proved our ability to develop a broad spectrum of free software. This does not mean we are invincible and unstoppable. Several challenges make the future of free software uncertain; meeting them will require steadfast effort and endurance, sometimes lasting for years. It will require the kind of determination that people display when they value their freedom and will not let anyone take it away.

The following four sections discuss these challenges.

Secret hardware
Hardware manufacturers increasingly tend to keep hardware specifications secret. This makes it difficult to write free drivers so that Linux and XFree86 can support new hardware. We have complete free systems today, but we will not have them tomorrow if we cannot support tomorrow's computers.

There are two ways to cope with this problem. Programmers can do reverse engineering to figure out how to support the hardware. The rest of us can choose the hardware that is supported by free software; as our numbers increase, secrecy of specifications will become a self-defeating policy.

Reverse engineering is a big job; will we have programmers with sufficient determination to undertake it? Yes—if we have built up a strong feeling that free software is a matter of principle, and nonfree drivers are intolerable. And will large numbers of us spend extra money, or even a little extra time, so we can use free drivers? Yes, if the determination to have freedom is widespread.

(2008 note: this issue extends to the BIOS as well. There is a free BIOS, LibreBoot (a distribution of coreboot); the problem is getting specs for machines so that LibreBoot can support them without nonfree “blobs”.)

Nonfree libraries
A nonfree library that runs on free operating systems acts as a trap for free software developers. The library's attractive features are the bait; if you use the library, you fall into the trap, because your program cannot usefully be part of a free operating system. (Strictly speaking, we could include your program, but it won't run with the library missing.) Even worse, if a program that uses the proprietary library becomes popular, it can lure other unsuspecting programmers into the trap.

The first instance of this problem was the Motif toolkit, back in the 80s. Although there were as yet no free operating systems, it was clear what problem Motif would cause for them later on. The GNU Project responded in two ways: by asking individual free software projects to support the free X Toolkit widgets as well as Motif, and by asking for someone to write a free replacement for Motif. The job took many years; LessTif, developed by the Hungry Programmers, became powerful enough to support most Motif applications only in 1997.

Between 1996 and 1998, another nonfree GUI toolkit library, called Qt, was used in a substantial collection of free software, the desktop KDE.

Free GNU/Linux systems were unable to use KDE, because we could not use the library. However, some commercial distributors of GNU/Linux systems who were not strict about sticking with free software added KDE to their systems—producing a system with more capabilities, but less freedom. The KDE group was actively encouraging more programmers to use Qt, and millions of new “Linux users” had never been exposed to the idea that there was a problem in this. The situation appeared grim.

The free software community responded to the problem in two ways: GNOME and Harmony.

GNOME, the GNU Network Object Model Environment, is GNU's desktop project. Started in 1997 by Miguel de Icaza, and developed with the support of Red Hat Software, GNOME set out to provide similar desktop facilities, but using free software exclusively. It has technical advantages as well, such as supporting a variety of languages, not just C++. But its main purpose was freedom: not to require the use of any nonfree software.

Harmony is a compatible replacement library, designed to make it possible to run KDE software without using Qt.

In November 1998, the developers of Qt announced a change of license which, when carried out, should make Qt free software. There is no way to be sure, but I think that this was partly due to the community's firm response to the problem that Qt posed when it was nonfree. (The new license is inconvenient and inequitable, so it remains desirable to avoid using Qt.)

[Subsequent note: in September 2000, Qt was rereleased under the GNU GPL, which essentially solved this problem.]

How will we respond to the next tempting nonfree library? Will the whole community understand the need to stay out of the trap? Or will many of us give up freedom for convenience, and produce a major problem? Our future depends on our philosophy.

Software patents
The worst threat we face comes from software patents, which can put algorithms and features off limits to free software for up to twenty years. The LZW compression algorithm patents were applied for in 1983, and we still cannot release free software to produce proper compressed GIFs. [As of 2009 they have expired.] In 1998, a free program to produce MP3 compressed audio was removed from distribution under threat of a patent suit. [As of 2017, these patents have expired. Look how long we had to wait.]

There are ways to cope with patents: we can search for evidence that a patent is invalid, and we can look for alternative ways to do a job. But each of these methods works only sometimes; when both fail, a patent may force all free software to lack some feature that users want. After a long wait, the patents expire (the MP3 patents are expected to have expired by 2018), but what will we do until then?

Those of us who value free software for freedom's sake will stay with free software anyway. We will manage to get work done without the patented features. But those who value free software because they expect it to be technically superior are likely to call it a failure when a patent holds it back. Thus, while it is useful to talk about the practical effectiveness of the “bazaar” model of development, and the reliability and power of some free software, we must not stop there. We must talk about freedom and principle.

Free documentation
The biggest deficiency in our free operating systems is not in the software—it is the lack of good free manuals that we can include in our systems. Documentation is an essential part of any software package; when an important free software package does not come with a good free manual, that is a major gap. We have many such gaps today.

Free documentation, like free software, is a matter of freedom, not price. The criterion for a free manual is pretty much the same as for free software: it is a matter of giving all users certain freedoms. Redistribution (including commercial sale) must be permitted, online and on paper, so that the manual can accompany every copy of the program.

Permission for modification is crucial too. As a general rule, I don't believe that it is essential for people to have permission to modify all sorts of articles and books. For example, I don't think you or I are obliged to give permission to modify articles like this one, which describe our actions and our views.

But there is a particular reason why the freedom to modify is crucial for documentation for free software. When people exercise their right to modify the software, and add or change its features, if they are conscientious they will change the manual, too—so they can provide accurate and usable documentation with the modified program. A nonfree manual, which does not allow programmers to be conscientious and finish the job, does not fill our community's needs.

Some kinds of limits on how modifications are done pose no problem. For example, requirements to preserve the original author's copyright notice, the distribution terms, or the list of authors, are OK. It is also no problem to require modified versions to include notice that they were modified, even to have entire sections that may not be deleted or changed, as long as these sections deal with nontechnical topics. These kinds of restrictions are not a problem because they don't stop the conscientious programmer from adapting the manual to fit the modified program. In other words, they don't block the free software community from making full use of the manual.

However, it must be possible to modify all the technical content of the manual, and then distribute the result in all the usual media, through all the usual channels; otherwise, the restrictions do obstruct the community, the manual is not free, and we need another manual.

Will free software developers have the awareness and determination to produce a full spectrum of free manuals? Once again, our future depends on philosophy.

We must talk about freedom
Estimates today are that there are ten million users of GNU/Linux systems such as Debian GNU/Linux and Red Hat “Linux”. Free software has developed such practical advantages that users are flocking to it for purely practical reasons.

The good consequences of this are evident: more interest in developing free software, more customers for free software businesses, and more ability to encourage companies to develop commercial free software instead of proprietary software products.

But interest in the software is growing faster than awareness of the philosophy it is based on, and this leads to trouble. Our ability to meet the challenges and threats described above depends on the will to stand firm for freedom. To make sure our community has this will, we need to spread the idea to the new users as they come into the community.

But we are failing to do so: the efforts to attract new users into our community are far outstripping the efforts to teach them the civics of our community. We need to do both, and we need to keep the two efforts in balance.

“Open Source”
Teaching new users about freedom became more difficult in 1998, when a part of the community decided to stop using the term “free software” and say “open source software” instead.

Some who favored this term aimed to avoid the confusion of “free” with “gratis”—a valid goal. Others, however, aimed to set aside the spirit of principle that had motivated the free software movement and the GNU Project, and to appeal instead to executives and business users, many of whom hold an ideology that places profit above freedom, above community, above principle. Thus, the rhetoric of “open source” focuses on the potential to make high-quality, powerful software, but shuns the ideas of freedom, community, and principle.

The “Linux” magazines are a clear example of this—they are filled with advertisements for proprietary software that works with GNU/Linux. When the next Motif or Qt appears, will these magazines warn programmers to stay away from it, or will they run ads for it?

The support of business can contribute to the community in many ways; all else being equal, it is useful. But winning their support by speaking even less about freedom and principle can be disastrous; it makes the previous imbalance between outreach and civics education even worse.

“Free software” and “open source” describe the same category of software, more or less, but say different things about the software, and about values. The GNU Project continues to use the term “free software”, to express the idea that freedom, not just technology, is important.

Try!
Yoda's aphorism (“There is no ‘try’”) sounds neat, but it doesn't work for me. I have done most of my work while anxious about whether I could do the job, and unsure that it would be enough to achieve the goal if I did. But I tried anyway, because there was no one but me between the enemy and my city. Surprising myself, I have sometimes succeeded.

Sometimes I failed; some of my cities have fallen. Then I found another threatened city, and got ready for another battle. Over time, I've learned to look for threats and put myself between them and my city, calling on other hackers to come and join me.

Nowadays, often I'm not the only one. It is a relief and a joy when I see a regiment of hackers digging in to hold the line, and I realize, this city may survive—for now. But the dangers are greater each year, and now Microsoft has explicitly targeted our community. We can't take the future of freedom for granted. Don't take it for granted! If you want to keep your freedom, you must be prepared to defend it.


https://www.gnu.org/gnu/initial-announcement.html
Initial Announcement
This is the original announcement of the GNU Project, posted by Richard Stallman on September 27, 1983.

The actual history of the GNU Project differs in many ways from this initial plan. For example, the beginning was delayed until January 1984. Several of the philosophical concepts of free software were not clarified until a few years later.

Free Unix!
Starting this Thanksgiving I am going to write a complete Unix-compatible software system called GNU (for Gnu's Not Unix), and give it away free(1) to everyone who can use it. Contributions of time, money, programs and equipment are greatly needed.

To begin with, GNU will be a kernel plus all the utilities needed to write and run C programs: editor, shell, C compiler, linker, assembler, and a few other things. After this we will add a text formatter, a YACC, an Empire game, a spreadsheet, and hundreds of other things. We hope to supply, eventually, everything useful that normally comes with a Unix system, and anything else useful, including on-line and hardcopy documentation.

GNU will be able to run Unix programs, but will not be identical to Unix. We will make all improvements that are convenient, based on our experience with other operating systems. In particular, we plan to have longer filenames, file version numbers, a crashproof file system, filename completion perhaps, terminal-independent display support, and eventually a Lisp-based window system through which several Lisp programs and ordinary Unix programs can share a screen. Both C and Lisp will be available as system programming languages. We will have network software based on MIT's chaosnet protocol, far superior to UUCP. We may also have something compatible with UUCP.

Who Am I?
I am Richard Stallman, inventor of the original much-imitated EMACS editor, now at the Artificial Intelligence Lab at MIT. I have worked extensively on compilers, editors, debuggers, command interpreters, the Incompatible Timesharing System and the Lisp Machine operating system. I pioneered terminal-independent display support in ITS. In addition I have implemented one crashproof file system and two window systems for Lisp machines.

Why I Must Write GNU
I consider that the golden rule requires that if I like a program I must share it with other people who like it. I cannot in good conscience sign a nondisclosure agreement or a software license agreement.

So that I can continue to use computers without violating my principles, I have decided to put together a sufficient body of free software so that I will be able to get along without any software that is not free.

How You Can Contribute
I am asking computer manufacturers for donations of machines and money. I'm asking individuals for donations of programs and work.

One computer manufacturer has already offered to provide a machine. But we could use more. One consequence you can expect if you donate machines is that GNU will run on them at an early date. The machine had better be able to operate in a residential area, and not require sophisticated cooling or power.

Individual programmers can contribute by writing a compatible duplicate of some Unix utility and giving it to me. For most projects, such part-time distributed work would be very hard to coordinate; the independently-written parts would not work together. But for the particular task of replacing Unix, this problem is absent. Most interface specifications are fixed by Unix compatibility. If each contribution works with the rest of Unix, it will probably work with the rest of GNU.

If I get donations of money, I may be able to hire a few people full or part time. The salary won't be high, but I'm looking for people for whom knowing they are helping humanity is as important as money. I view this as a way of enabling dedicated people to devote their full energies to working on GNU by sparing them the need to make a living in another way.

For more information, contact me.

Arpanet mail:
RMS@MIT-MC.ARPA

Usenet:
...!mit-eddie!RMS@OZ
...!mit-vax!RMS@OZ

US Snail:
Richard Stallman
166 Prospect St
Cambridge, MA 02139

Poor choice of wording around “free”
The wording here was careless. The intention was that nobody would have to pay for permission to use the GNU system. But the words don't make this clear, and people often interpret them as saying that copies of GNU should always be distributed at little or no charge. That was never the intent.


https://www.gnu.org/gnu/manifesto.html
The GNU Manifesto
The GNU Manifesto (which appears below) was written by Richard Stallman in 1985 to ask for support in developing the GNU operating system. Part of the text was taken from the original announcement of 1983. Through 1987, it was updated in minor ways to account for developments; since then, it seems best to leave it unchanged.

Since that time, we have learned about certain common misunderstandings that different wording could help avoid. Footnotes added since 1993 help clarify these points.

If you want to install the GNU/Linux system, we recommend you use one of the 100% free software GNU/Linux distributions. For how to contribute, see http://www.gnu.org/help.

The GNU Project is part of the Free Software Movement, a campaign for freedom for users of software. It is a mistake to associate GNU with the term “open source”—that term was coined in 1998 by people who disagree with the Free Software Movement's ethical values. They use it to promote an amoral approach to the same field.

What's GNU? Gnu's Not Unix!
GNU, which stands for Gnu's Not Unix, is the name for the complete Unix-compatible software system which I am writing so that I can give it away free to everyone who can use it.(1) Several other volunteers are helping me. Contributions of time, money, programs and equipment are greatly needed.

So far we have an Emacs text editor with Lisp for writing editor commands, a source level debugger, a yacc-compatible parser generator, a linker, and around 35 utilities. A shell (command interpreter) is nearly completed. A new portable optimizing C compiler has compiled itself and may be released this year. An initial kernel exists but many more features are needed to emulate Unix. When the kernel and compiler are finished, it will be possible to distribute a GNU system suitable for program development. We will use TeX as our text formatter, but an nroff is being worked on. We will use the free, portable X Window System as well. After this we will add a portable Common Lisp, an Empire game, a spreadsheet, and hundreds of other things, plus online documentation. We hope to supply, eventually, everything useful that normally comes with a Unix system, and more.

GNU will be able to run Unix programs, but will not be identical to Unix. We will make all improvements that are convenient, based on our experience with other operating systems. In particular, we plan to have longer file names, file version numbers, a crashproof file system, file name completion perhaps, terminal-independent display support, and perhaps eventually a Lisp-based window system through which several Lisp programs and ordinary Unix programs can share a screen. Both C and Lisp will be available as system programming languages. We will try to support UUCP, MIT Chaosnet, and Internet protocols for communication.

GNU is aimed initially at machines in the 68000/16000 class with virtual memory, because they are the easiest machines to make it run on. The extra effort to make it run on smaller machines will be left to someone who wants to use it on them.

To avoid horrible confusion, please pronounce the g in the word “GNU” when it is the name of this project.

Why I Must Write GNU
I consider that the Golden Rule requires that if I like a program I must share it with other people who like it. Software sellers want to divide the users and conquer them, making each user agree not to share with others. I refuse to break solidarity with other users in this way. I cannot in good conscience sign a nondisclosure agreement or a software license agreement. For years I worked within the Artificial Intelligence Lab to resist such tendencies and other inhospitalities, but eventually they had gone too far: I could not remain in an institution where such things are done for me against my will.

So that I can continue to use computers without dishonor, I have decided to put together a sufficient body of free software so that I will be able to get along without any software that is not free. I have resigned from the AI Lab to deny MIT any legal excuse to prevent me from giving GNU away.(2)

Why GNU Will Be Compatible with Unix
Unix is not my ideal system, but it is not too bad. The essential features of Unix seem to be good ones, and I think I can fill in what Unix lacks without spoiling them. And a system compatible with Unix would be convenient for many other people to adopt.

How GNU Will Be Available
GNU is not in the public domain. Everyone will be permitted to modify and redistribute GNU, but no distributor will be allowed to restrict its further redistribution. That is to say, proprietary modifications will not be allowed. I want to make sure that all versions of GNU remain free.

Why Many Other Programmers Want to Help
I have found many other programmers who are excited about GNU and want to help.

Many programmers are unhappy about the commercialization of system software. It may enable them to make more money, but it requires them to feel in conflict with other programmers in general rather than feel as comrades. The fundamental act of friendship among programmers is the sharing of programs; marketing arrangements now typically used essentially forbid programmers to treat others as friends. The purchaser of software must choose between friendship and obeying the law. Naturally, many decide that friendship is more important. But those who believe in law often do not feel at ease with either choice. They become cynical and think that programming is just a way of making money.

By working on and using GNU rather than proprietary programs, we can be hospitable to everyone and obey the law. In addition, GNU serves as an example to inspire and a banner to rally others to join us in sharing. This can give us a feeling of harmony which is impossible if we use software that is not free. For about half the programmers I talk to, this is an important happiness that money cannot replace.

How You Can Contribute
(Nowadays, for software tasks to work on, see the High Priority Projects list and the GNU Help Wanted list, the general task list for GNU software packages. For other ways to help, see the guide to helping the GNU operating system.)

I am asking computer manufacturers for donations of machines and money. I'm asking individuals for donations of programs and work.

One consequence you can expect if you donate machines is that GNU will run on them at an early date. The machines should be complete, ready to use systems, approved for use in a residential area, and not in need of sophisticated cooling or power.

I have found very many programmers eager to contribute part-time work for GNU. For most projects, such part-time distributed work would be very hard to coordinate; the independently written parts would not work together. But for the particular task of replacing Unix, this problem is absent. A complete Unix system contains hundreds of utility programs, each of which is documented separately. Most interface specifications are fixed by Unix compatibility. If each contributor can write a compatible replacement for a single Unix utility, and make it work properly in place of the original on a Unix system, then these utilities will work right when put together. Even allowing for Murphy to create a few unexpected problems, assembling these components will be a feasible task. (The kernel will require closer communication and will be worked on by a small, tight group.)

If I get donations of money, I may be able to hire a few people full or part time. The salary won't be high by programmers' standards, but I'm looking for people for whom building community spirit is as important as making money. I view this as a way of enabling dedicated people to devote their full energies to working on GNU by sparing them the need to make a living in another way.

Why All Computer Users Will Benefit
Once GNU is written, everyone will be able to obtain good system software free, just like air.(3)

This means much more than just saving everyone the price of a Unix license. It means that much wasteful duplication of system programming effort will be avoided. This effort can go instead into advancing the state of the art.

Complete system sources will be available to everyone. As a result, a user who needs changes in the system will always be free to make them himself, or hire any available programmer or company to make them for him. Users will no longer be at the mercy of one programmer or company which owns the sources and is in sole position to make changes.

Schools will be able to provide a much more educational environment by encouraging all students to study and improve the system code. Harvard's computer lab used to have the policy that no program could be installed on the system if its sources were not on public display, and upheld it by actually refusing to install certain programs. I was very much inspired by this.

Finally, the overhead of considering who owns the system software and what one is or is not entitled to do with it will be lifted.

Arrangements to make people pay for using a program, including licensing of copies, always incur a tremendous cost to society through the cumbersome mechanisms necessary to figure out how much (that is, which programs) a person must pay for. And only a police state can force everyone to obey them. Consider a space station where air must be manufactured at great cost: charging each breather per liter of air may be fair, but wearing the metered gas mask all day and all night is intolerable even if everyone can afford to pay the air bill. And the TV cameras everywhere to see if you ever take the mask off are outrageous. It's better to support the air plant with a head tax and chuck the masks.

Copying all or parts of a program is as natural to a programmer as breathing, and as productive. It ought to be as free.

Some Easily Rebutted Objections to GNU's Goals
“Nobody will use it if it is free, because that means they can't rely on any support.”

“You have to charge for the program to pay for providing the support.”

If people would rather pay for GNU plus service than get GNU free without service, a company to provide just service to people who have obtained GNU free ought to be profitable.(4)

We must distinguish between support in the form of real programming work and mere handholding. The former is something one cannot rely on from a software vendor. If your problem is not shared by enough people, the vendor will tell you to get lost.

If your business needs to be able to rely on support, the only way is to have all the necessary sources and tools. Then you can hire any available person to fix your problem; you are not at the mercy of any individual. With Unix, the price of sources puts this out of consideration for most businesses. With GNU this will be easy. It is still possible for there to be no available competent person, but this problem cannot be blamed on distribution arrangements. GNU does not eliminate all the world's problems, only some of them.

Meanwhile, the users who know nothing about computers need handholding: doing things for them which they could easily do themselves but don't know how.

Such services could be provided by companies that sell just handholding and repair service. If it is true that users would rather spend money and get a product with service, they will also be willing to buy the service having got the product free. The service companies will compete in quality and price; users will not be tied to any particular one. Meanwhile, those of us who don't need the service should be able to use the program without paying for the service.

“You cannot reach many people without advertising, and you must charge for the program to support that.”

“It's no use advertising a program people can get free.”

There are various forms of free or very cheap publicity that can be used to inform numbers of computer users about something like GNU. But it may be true that one can reach more microcomputer users with advertising. If this is really so, a business which advertises the service of copying and mailing GNU for a fee ought to be successful enough to pay for its advertising and more. This way, only the users who benefit from the advertising pay for it.

On the other hand, if many people get GNU from their friends, and such companies don't succeed, this will show that advertising was not really necessary to spread GNU. Why is it that free market advocates don't want to let the free market decide this?(5)

“My company needs a proprietary operating system to get a competitive edge.”

GNU will remove operating system software from the realm of competition. You will not be able to get an edge in this area, but neither will your competitors be able to get an edge over you. You and they will compete in other areas, while benefiting mutually in this one. If your business is selling an operating system, you will not like GNU, but that's tough on you. If your business is something else, GNU can save you from being pushed into the expensive business of selling operating systems.

I would like to see GNU development supported by gifts from many manufacturers and users, reducing the cost to each.(6)

“Don't programmers deserve a reward for their creativity?”

If anything deserves a reward, it is social contribution. Creativity can be a social contribution, but only in so far as society is free to use the results. If programmers deserve to be rewarded for creating innovative programs, by the same token they deserve to be punished if they restrict the use of these programs.

“Shouldn't a programmer be able to ask for a reward for his creativity?”

There is nothing wrong with wanting pay for work, or seeking to maximize one's income, as long as one does not use means that are destructive. But the means customary in the field of software today are based on destruction.

Extracting money from users of a program by restricting their use of it is destructive because the restrictions reduce the amount and the ways that the program can be used. This reduces the amount of wealth that humanity derives from the program. When there is a deliberate choice to restrict, the harmful consequences are deliberate destruction.

The reason a good citizen does not use such destructive means to become wealthier is that, if everyone did so, we would all become poorer from the mutual destructiveness. This is Kantian ethics; or, the Golden Rule. Since I do not like the consequences that result if everyone hoards information, I am required to consider it wrong for one to do so. Specifically, the desire to be rewarded for one's creativity does not justify depriving the world in general of all or part of that creativity.

“Won't programmers starve?”

I could answer that nobody is forced to be a programmer. Most of us cannot manage to get any money for standing on the street and making faces. But we are not, as a result, condemned to spend our lives standing on the street making faces, and starving. We do something else.

But that is the wrong answer because it accepts the questioner's implicit assumption: that without ownership of software, programmers cannot possibly be paid a cent. Supposedly it is all or nothing.

The real reason programmers will not starve is that it will still be possible for them to get paid for programming; just not paid as much as now.

Restricting copying is not the only basis for business in software. It is the most common basis(7) because it brings in the most money. If it were prohibited, or rejected by the customer, software business would move to other bases of organization which are now used less often. There are always numerous ways to organize any kind of business.

Probably programming will not be as lucrative on the new basis as it is now. But that is not an argument against the change. It is not considered an injustice that sales clerks make the salaries that they now do. If programmers made the same, that would not be an injustice either. (In practice they would still make considerably more than that.)

“Don't people have a right to control how their creativity is used?”

“Control over the use of one's ideas” really constitutes control over other people's lives; and it is usually used to make their lives more difficult.

People who have studied the issue of intellectual property rights(8) carefully (such as lawyers) say that there is no intrinsic right to intellectual property. The kinds of supposed intellectual property rights that the government recognizes were created by specific acts of legislation for specific purposes.

For example, the patent system was established to encourage inventors to disclose the details of their inventions. Its purpose was to help society rather than to help inventors. At the time, the life span of 17 years for a patent was short compared with the rate of advance of the state of the art. Since patents are an issue only among manufacturers, for whom the cost and effort of a license agreement are small compared with setting up production, the patents often do not do much harm. They do not obstruct most individuals who use patented products.

The idea of copyright did not exist in ancient times, when authors frequently copied other authors at length in works of nonfiction. This practice was useful, and is the only way many authors' works have survived even in part. The copyright system was created expressly for the purpose of encouraging authorship. In the domain for which it was invented—books, which could be copied economically only on a printing press—it did little harm, and did not obstruct most of the individuals who read the books.

All intellectual property rights are just licenses granted by society because it was thought, rightly or wrongly, that society as a whole would benefit by granting them. But in any particular situation, we have to ask: are we really better off granting such license? What kind of act are we licensing a person to do?

The case of programs today is very different from that of books a hundred years ago. The fact that the easiest way to copy a program is from one neighbor to another, the fact that a program has both source code and object code which are distinct, and the fact that a program is used rather than read and enjoyed, combine to create a situation in which a person who enforces a copyright is harming society as a whole both materially and spiritually; in which a person should not do so regardless of whether the law enables him to.

“Competition makes things get done better.”

The paradigm of competition is a race: by rewarding the winner, we encourage everyone to run faster. When capitalism really works this way, it does a good job; but its defenders are wrong in assuming it always works this way. If the runners forget why the reward is offered and become intent on winning, no matter how, they may find other strategies—such as, attacking other runners. If the runners get into a fist fight, they will all finish late.

Proprietary and secret software is the moral equivalent of runners in a fist fight. Sad to say, the only referee we've got does not seem to object to fights; he just regulates them (“For every ten yards you run, you can fire one shot”). He really ought to break them up, and penalize runners for even trying to fight.

“Won't everyone stop programming without a monetary incentive?”

Actually, many people will program with absolutely no monetary incentive. Programming has an irresistible fascination for some people, usually the people who are best at it. There is no shortage of professional musicians who keep at it even though they have no hope of making a living that way.

But really this question, though commonly asked, is not appropriate to the situation. Pay for programmers will not disappear, only become less. So the right question is, will anyone program with a reduced monetary incentive? My experience shows that they will.

For more than ten years, many of the world's best programmers worked at the Artificial Intelligence Lab for far less money than they could have had anywhere else. They got many kinds of nonmonetary rewards: fame and appreciation, for example. And creativity is also fun, a reward in itself.

Then most of them left when offered a chance to do the same interesting work for a lot of money.

What the facts show is that people will program for reasons other than riches; but if given a chance to make a lot of money as well, they will come to expect and demand it. Low-paying organizations do poorly in competition with high-paying ones, but they do not have to do badly if the high-paying ones are banned.

“We need the programmers desperately. If they demand that we stop helping our neighbors, we have to obey.”

You're never so desperate that you have to obey this sort of demand. Remember: millions for defense, but not a cent for tribute!

“Programmers need to make a living somehow.”

In the short run, this is true. However, there are plenty of ways that programmers could make a living without selling the right to use a program. This way is customary now because it brings programmers and businessmen the most money, not because it is the only way to make a living. It is easy to find other ways if you want to find them. Here are a number of examples.

A manufacturer introducing a new computer will pay for the porting of operating systems onto the new hardware.

The sale of teaching, handholding and maintenance services could also employ programmers.

People with new ideas could distribute programs as freeware(9), asking for donations from satisfied users, or selling handholding services. I have met people who are already working this way successfully.

Users with related needs can form users' groups, and pay dues. A group would contract with programming companies to write programs that the group's members would like to use.

All sorts of development can be funded with a Software Tax:

Suppose everyone who buys a computer has to pay x percent of the price as a software tax. The government gives this to an agency like the NSF to spend on software development.

But if the computer buyer makes a donation to software development himself, he can take a credit against the tax. He can donate to the project of his own choosing—often, chosen because he hopes to use the results when it is done. He can take a credit for any amount of donation up to the total tax he had to pay.

The total tax rate could be decided by a vote of the payers of the tax, weighted according to the amount they will be taxed on.

The consequences:

The computer-using community supports software development.
This community decides what level of support is needed.
Users who care which projects their share is spent on can choose this for themselves.
In the long run, making programs free is a step toward the postscarcity world, where nobody will have to work very hard just to make a living. People will be free to devote themselves to activities that are fun, such as programming, after spending the necessary ten hours a week on required tasks such as legislation, family counseling, robot repair and asteroid prospecting. There will be no need to be able to make a living from programming.

We have already greatly reduced the amount of work that the whole society must do for its actual productivity, but only a little of this has translated itself into leisure for workers because much nonproductive activity is required to accompany productive activity. The main causes of this are bureaucracy and isometric struggles against competition. Free software will greatly reduce these drains in the area of software production. We must do this, in order for technical gains in productivity to translate into less work for us.

Footnotes
The wording here was careless. The intention was that nobody would have to pay for permission to use the GNU system. But the words don't make this clear, and people often interpret them as saying that copies of GNU should always be distributed at little or no charge. That was never the intent; later on, the manifesto mentions the possibility of companies providing the service of distribution for a profit. Subsequently I have learned to distinguish carefully between “free” in the sense of freedom and “free” in the sense of price. Free software is software that users have the freedom to distribute and change. Some users may obtain copies at no charge, while others pay to obtain copies—and if the funds help support improving the software, so much the better. The important thing is that everyone who has a copy has the freedom to cooperate with others in using it.
The expression “give away” is another indication that I had not yet clearly separated the issue of price from that of freedom. We now recommend avoiding this expression when talking about free software. See “Confusing Words and Phrases” for more explanation.
This is another place I failed to distinguish carefully between the two different meanings of “free”. The statement as it stands is not false—you can get copies of GNU software at no charge, from your friends or over the net. But it does suggest the wrong idea.
Several such companies now exist.
Although it is a charity rather than a company, the Free Software Foundation for 10 years raised most of its funds from its distribution service. You can order things from the FSF to support its work.
A group of computer companies pooled funds around 1991 to support maintenance of the GNU C Compiler.
I think I was mistaken in saying that proprietary software was the most common basis for making money in software. It seems that actually the most common business model was and is development of custom software. That does not offer the possibility of collecting rents, so the business has to keep doing real work in order to keep getting income. The custom software business would continue to exist, more or less unchanged, in a free software world. Therefore, I no longer expect that most paid programmers would earn less in a free software world.
In the 1980s I had not yet realized how confusing it was to speak of “the issue” of “intellectual property”. That term is obviously biased; more subtle is the fact that it lumps together various disparate laws which raise very different issues. Nowadays I urge people to reject the term “intellectual property” entirely, lest it lead others to suppose that those laws form one coherent issue. The way to be clear is to discuss patents, copyrights, and trademarks separately. See further explanation of how this term spreads confusion and bias.
Subsequently we learned to distinguish between “free software” and “freeware”. The term “freeware” means software you are free to redistribute, but usually you are not free to study and change the source code, so most of it is not free software. See “Confusing Words and Phrases” for more explanation.


https://www.gnu.org/gnu/byte-interview.html
BYTE Interview with Richard Stallman
Conducted by David Betz and Jon Edwards

Richard Stallman discusses his public-domain Unix-compatible software system with BYTE editors (July 1986)
Richard Stallman has undertaken probably the most ambitious free software development project to date, the GNU system. In his GNU Manifesto, published in the March 1985 issue of Dr. Dobb's Journal, Stallman described GNU as a “complete Unix-compatible software system which I am writing so that I can give it away free to everyone who can use it… Once GNU is written, everyone will be able to obtain good system software free, just like air.” (GNU is an acronym for GNU's Not Unix; the “G” is pronounced.)

Stallman is widely known as the author of EMACS, a powerful text editor that he developed at the MIT Artificial Intelligence Laboratory. It is no coincidence that the first piece of software produced as part of the GNU project was a new implementation of EMACS. GNU EMACS has already achieved a reputation as one of the best implementations of EMACS currently available at any price.

BYTE: We read your GNU Manifesto in the March 1985 issue of Dr. Dobb's. What has happened since? Was that really the beginning, and how have you progressed since then?

Stallman: The publication in Dr. Dobb's wasn't the beginning of the project. I wrote the GNU Manifesto when I was getting ready to start the project, as a proposal to ask computer manufacturers for funding. They didn't want to get involved, and I decided that rather than spend my time trying to pursue funds, I ought to spend it writing code. The manifesto was published about a year and a half after I had written it, when I had barely begun distributing the GNU EMACS. Since that time, in addition to making GNU EMACS more complete and making it run on many more computers, I have nearly finished the optimizing C compiler and all the other software that is needed for running C programs. This includes a source-level debugger that has many features that the other source-level debuggers on Unix don't have. For example, it has convenience variables within the debugger so you can save values, and it also has a history of all the values that you have printed out, making it tremendously easier to chase around list structures.

BYTE: You have finished an editor that is now widely distributed and you are about to finish the compiler.

Stallman: I expect that it will be finished this October.

BYTE: What about the kernel?

Stallman: I'm currently planning to start with the kernel that was written at MIT and was released to the public recently with the idea that I would use it. This kernel is called TRIX; it's based on remote procedure call. I still need to add compatibility for a lot of the features of Unix which it doesn't have currently. I haven't started to work on that yet. I'm finishing the compiler before I go to work on the kernel. I am also going to have to rewrite the file system. I intend to make it failsafe just by having it write blocks in the proper order so that the disk structure is always consistent. Then I want to add version numbers. I have a complicated scheme to reconcile version numbers with the way people usually use Unix. You have to be able to specify filenames without version numbers, but you also have to be able to specify them with explicit version numbers, and these both need to work with ordinary Unix programs that have not been modified in any way to deal with the existence of this feature. I think I have a scheme for doing this, and only trying it will show me whether it really does the job.

BYTE: Do you have a brief description you can give us as to how GNU as a system will be superior to other systems? We know that one of your goals is to produce something that is compatible with Unix. But at least in the area of file systems you have already said that you are going to go beyond Unix and produce something that is better.

Stallman: The C compiler will produce better code and run faster. The debugger is better. With each piece I may or may not find a way to improve it. But there is no one answer to this question. To some extent I am getting the benefit of reimplementation, which makes many systems much better. To some extent it's because I have been in the field a long time and worked on many other systems. I therefore have many ideas to bring to bear. One way in which it will be better is that practically everything in the system will work on files of any size, on lines of any size, with any characters appearing in them. The Unix system is very bad in that regard. It's not anything new as a principle of software engineering that you shouldn't have arbitrary limits. But it just was the standard practice in writing Unix to put those in all the time, possibly just because they were writing it for a very small computer. The only limit in the GNU system is when your program runs out of memory because it tried to work on too much data and there is no place to keep it all.

BYTE: And that isn't likely to be hit if you've got virtual memory. You may just take forever to come up with the solution.

Stallman: Actually these limits tend to hit in a time long before you take forever to come up with the solution.

BYTE: Can you say something about what types of machines and environments GNU EMACS in particular has been made to run under? It's now running on VAXes; has it migrated in any form to personal computers?

Stallman: I'm not sure what you mean by personal computers. For example, is a Sun a personal computer? GNU EMACS requires at least a megabyte of available memory and preferably more. It is normally used on machines that have virtual memory. Except for various technical problems in a few C compilers, almost any machine with virtual memory and running a fairly recent version of Unix will run GNU EMACS, and most of them currently do.

BYTE: Has anyone tried to port it to Ataris or Macintoshes?

Stallman: The Atari 1040ST still doesn't have quite enough memory. The next Atari machine, I expect, will run it. I also think that future Ataris will have some forms of memory mapping. Of course, I am not designing the software to run on the kinds of computers that are prevalent today. I knew when I started this project it was going to take a few years. I therefore decided that I didn't want to make a worse system by taking on the additional challenge of making it run in the currently constrained environment. So instead I decided I'm going to write it in the way that seems the most natural and best. I am confident that in a couple of years machines of sufficient size will be prevalent. In fact, increases in memory size are happening so fast it surprises me how slow most of the people are to put in virtual memory; I think it is totally essential.

BYTE: I think people don't really view it as being necessary for single-user machines.

Stallman: They don't understand that single user doesn't mean single program. Certainly for any Unix-like system it's important to be able to run lots of different processes at the same time even if there is only one of you. You could run GNU EMACS on a nonvirtual-memory machine with enough memory, but you couldn't run the rest of the GNU system very well or a Unix system very well.

BYTE: How much of LISP is present in GNU EMACS? It occurred to me that it may be useful to use that as a tool for learning LISP.

Stallman: You can certainly do that. GNU EMACS contains a complete, although not very powerful, LISP system. It's powerful enough for writing editor commands. It's not comparable with, say, a Common LISP System, something you could really use for system programming, but it has all the things that LISP needs to have.

BYTE: Do you have any predictions about when you would be likely to distribute a workable environment in which, if we put it on our machines or workstations, we could actually get reasonable work done without using anything other than code that you distribute?

Stallman: It's really hard to say. That could happen in a year, but of course it could take longer. It could also conceivably take less, but that's not too likely anymore. I think I'll have the compiler finished in a month or two. The only other large piece of work I really have to do is in the kernel. I first predicted GNU would take something like two years, but it has now been two and a half years and I'm still not finished. Part of the reason for the delay is that I spent a lot of time working on one compiler that turned out to be a dead end. I had to rewrite it completely. Another reason is that I spent so much time on GNU EMACS. I originally thought I wouldn't have to do that at all.

BYTE: Tell us about your distribution scheme.

Stallman: I don't put software or manuals in the public domain, and the reason is that I want to make sure that all the users get the freedom to share. I don't want anyone making an improved version of a program I wrote and distributing it as proprietary. I don't want that to ever be able to happen. I want to encourage the free improvements to these programs, and the best way to do that is to take away any temptation for a person to make improvements nonfree. Yes, a few of them will refrain from making improvements, but a lot of others will make the same improvements and they'll make them free.

BYTE: And how do you go about guaranteeing that?

Stallman: I do this by copyrighting the programs and putting on a notice giving people explicit permission to copy the programs and change them but only on the condition that they distribute under the same terms that I used, if at all. You don't have to distribute the changes you make to any of my programs—you can just do it for yourself, and you don't have to give it to anyone or tell anyone. But if you do give it to someone else, you have to do it under the same terms that I use.

BYTE: Do you obtain any rights over the executable code derived from the C compiler?

Stallman: The copyright law doesn't give me copyright on output from the compiler, so it doesn't give me a way to say anything about that, and in fact I don't try to. I don't sympathize with people developing proprietary products with any compiler, but it doesn't seem especially useful to try to stop them from developing them with this compiler, so I am not going to.

BYTE: Do your restrictions apply if people take pieces of your code to produce other things as well?

Stallman: Yes, if they incorporate with changes any sizable piece. If it were two lines of code, that's nothing; copyright doesn't apply to that. Essentially, I have chosen these conditions so that first there is a copyright, which is what all the software hoarders use to stop everybody from doing anything, and then I add a notice giving up part of those rights. So the conditions talk only about the things that copyright applies to. I don't believe that the reason you should obey these conditions is because of the law. The reason you should obey is because an upright person when he distributes software encourages other people to share it further.

BYTE: In a sense you are enticing people into this mode of thinking by providing all of these interesting tools that they can use but only if they buy into your philosophy.

Stallman: Yes. You could also see it as using the legal system that software hoarders have set up against them. I'm using it to protect the public from them.

BYTE: Given that manufacturers haven't wanted to fund the project, who do you think will use the GNU system when it is done?

Stallman: I have no idea, but it is not an important question. My purpose is to make it possible for people to reject the chains that come with proprietary software. I know that there are people who want to do that. Now, there may be others who don't care, but they are not my concern. I feel a bit sad for them and for the people that they influence. Right now a person who perceives the unpleasantness of the terms of proprietary software feels that he is stuck and has no alternative except not to use a computer. Well, I am going to give him a comfortable alternative.

Other people may use the GNU system simply because it is technically superior. For example, my C compiler is producing about as good a code as I have seen from any C compiler. And GNU EMACS is generally regarded as being far superior to the commercial competition. And GNU EMACS was not funded by anyone either, but everyone is using it. I therefore think that many people will use the rest of the GNU system because of its technical advantages. But I would be doing a GNU system even if I didn't know how to make it technically better because I want it to be socially better. The GNU project is really a social project. It uses technical means to make a change in society.

BYTE: Then it is fairly important to you that people adopt GNU. It is not just an academic exercise to produce this software to give it away to people. You hope it will change the way the software industry operates.

Stallman: Yes. Some people say no one will ever use it because it doesn't have some attractive corporate logo on it, and other people say that they think it is tremendously important and everyone's going to want to use it. I have no way of knowing what is really going to happen. I don't know any other way to try to change the ugliness of the field that I find myself in, so this is what I have to do.

BYTE: Can you address the implications? You obviously feel that this is an important political and social statement.

Stallman: It is a change. I'm trying to change the way people approach knowledge and information in general. I think that to try to own knowledge, to try to control whether people are allowed to use it, or to try to stop other people from sharing it, is sabotage. It is an activity that benefits the person that does it at the cost of impoverishing all of society. One person gains one dollar by destroying two dollars' worth of wealth. I think a person with a conscience wouldn't do that sort of thing except perhaps if he would otherwise die. And of course the people who do this are fairly rich; I can only conclude that they are unscrupulous. I would like to see people get rewards for writing free software and for encouraging other people to use it. I don't want to see people get rewards for writing proprietary software because that is not really a contribution to society. The principle of capitalism is the idea that people manage to make money by producing things and thereby are encouraged to do what is useful, automatically, so to speak. But that doesn't work when it comes to owning knowledge. They are encouraged to do not really what's useful, and what really is useful is not encouraged. I think it is important to say that information is different from material objects like cars and loaves of bread because people can copy it and share it on their own and, if nobody attempts to stop them, they can change it and make it better for themselves. That is a useful thing for people to do. This isn't true of loaves of bread. If you have one loaf of bread and you want another, you can't just put your loaf of bread into a bread copier. You can't make another one except by going through all the steps that were used to make the first one. It therefore is irrelevant whether people are permitted to copy it—it's impossible.

Books were printed only on printing presses until recently. It was possible to make a copy yourself by hand, but it wasn't practical because it took so much more work than using a printing press. And it produced something so much less attractive that, for all intents and purposes, you could act as if it were impossible to make books except by mass producing them. And therefore copyright didn't really take any freedom away from the reading public. There wasn't anything that a book purchaser could do that was forbidden by copyright.

But this isn't true for computer programs. It's also not true for tape cassettes. It's partly false now for books, but it is still true that for most books it is more expensive and certainly a lot more work to Xerox them than to buy a copy, and the result is still less attractive. Right now we are in a period where the situation that made copyright harmless and acceptable is changing to a situation where copyright will become destructive and intolerable. So the people who are slandered as “pirates” are in fact the people who are trying to do something useful that they have been forbidden to do. The copyright laws are entirely designed to help people take complete control over the use of some information for their own good. But they aren't designed to help people who want to make sure that the information is accessible to the public and stop others from depriving the public. I think that the law should recognize a class of works that are owned by the public, which is different from public domain in the same sense that a public park is different from something found in a garbage can. It's not there for anybody to take away, it's there for everyone to use but for no one to impede. Anybody in the public who finds himself being deprived of the derivative work of something owned by the public should be able to sue about it.

BYTE: But aren't pirates interested in getting copies of programs because they want to use those programs, not because they want to use that knowledge to produce something better?

Stallman: I don't see that that's the important distinction. More people using a program means that the program contributes more to society. You have a loaf of bread that could be eaten either once or a million times.

BYTE: Some users buy commercial software to obtain support. How does your distribution scheme provide support?

Stallman: I suspect that those users are misled and are not thinking clearly. It is certainly useful to have support, but when they start thinking about how that has something to do with selling software or with the software being proprietary, at that point they are confusing themselves. There is no guarantee that proprietary software will receive good support. Simply because sellers say that they provide support, that doesn't mean it will be any good. And they may go out of business. In fact, people think that GNU EMACS has better support than commercial EMACSes. One of the reasons is that I'm probably a better hacker than the people who wrote the other EMACSes, but the other reason is that everyone has sources and there are so many people interested in figuring out how to do things with it that you don't have to get your support from me. Even just the free support that consists of my fixing bugs people report to me and incorporating that in the next release has given people a good level of support. You can always hire somebody to solve a problem for you, and when the software is free you have a competitive market for the support. You can hire anybody. I distribute a service list with EMACS, a list of people's names and phone numbers and what they charge to provide support.

BYTE: Do you collect their bug fixes?

Stallman: Well, they send them to me. I asked all the people who wanted to be listed to promise that they would never ask any of their customers to keep secret whatever they were told or any changes they were given to the GNU software as part of that support.

BYTE: So you can't have people competing to provide support based on their knowing the solution to some problem that somebody else doesn't know.

Stallman: No. They can compete based on their being clever and more likely to find the solution to your problem, or their already understanding more of the common problems, or knowing better how to explain to you what you should do. These are all ways they can compete. They can try to do better, but they cannot actively impede their competitors.

BYTE: I suppose it's like buying a car. You're not forced to go back to the original manufacturer for support or continued maintenance.

Stallman: Or buying a house—what would it be like if the only person who could ever fix problems with your house was the contractor who built it originally? That is the kind of imposition that's involved in proprietary software. People tell me about a problem that happens in Unix. Because manufacturers sell improved versions of Unix, they tend to collect fixes and not give them out except in binaries. The result is that the bugs don't really get fixed.

BYTE: They're all duplicating effort trying to solve bugs independently.

Stallman: Yes. Here is another point that helps put the problem of proprietary information in a social perspective. Think about the liability insurance crisis. In order to get any compensation from society, an injured person has to hire a lawyer and split the money with that lawyer. This is a stupid and inefficient way of helping out people who are victims of accidents. And consider all the time that people put into hustling to take business away from their competition. Think of the pens that are packaged in large cardboard packages that cost more than the pen—just to make sure that the pen isn't stolen. Wouldn't it be better if we just put free pens on every street corner? And think of all the toll booths that impede the flow of traffic. It's a gigantic social phenomenon. People find ways of getting money by impeding society. Once they can impede society, they can be paid to leave people alone. The waste inherent in owning information will become more and more important and will ultimately make the difference between the utopia in which nobody really has to work for a living because it's all done by robots and a world just like ours where everyone spends much time replicating what the next fellow is doing.

BYTE: Like typing in copyright notices on the software.

Stallman: More like policing everyone to make sure that they don't have forbidden copies of anything and duplicating all the work people have already done because it is proprietary.

BYTE: A cynic might wonder how you earn your living.

Stallman: From consulting. When I do consulting, I always reserve the right to give away what I wrote for the consulting job. Also, I could be making my living by mailing copies of the free software that I wrote and some that other people wrote. Lots of people send in $150 for GNU EMACS, but now this money goes to the Free Software Foundation that I started. The foundation doesn't pay me a salary because it would be a conflict of interest. Instead, it hires other people to work on GNU. As long as I can go on making a living by consulting I think that's the best way.

BYTE: What is currently included in the official GNU distribution tape?

Stallman: Right now the tape contains GNU EMACS (one version fits all computers); Bison, a program that replaces YACC; MIT Scheme, which is Professor Sussman's super-simplified dialect of LISP; and Hack, a dungeon-exploring game similar to Rogue.

BYTE: Does the printed manual come with the tape as well?

Stallman: No. Printed manuals cost $15 each or copy them yourself. Copy this interview and share it, too.

BYTE: How can you get a copy of that?

Stallman: Write to the Free Software Foundation, 675 Massachusetts Ave., Cambridge, MA 02139.

[The current address (since 2005) is: Free Software Foundation 51 Franklin St, Fifth Floor Boston, MA 02110-1301, USA Voice: +1-617-542-5942 Fax: +1-617-542-2652]

BYTE: What are you going to do when you are done with the GNU system?

Stallman: I'm not sure. Sometimes I think that what I'll go on to do is the same thing in other areas of software.

BYTE: So this is just the first of a whole series of assaults on the software industry?

Stallman: I hope so. But perhaps what I'll do is just live a life of ease working a little bit of the time just to live. I don't have to live expensively. The rest of the time I can find interesting people to hang around with or learn to do things that I don't know how to do.


https://www.gnu.org/gnu/rms-lisp.html
My Lisp Experiences and the Development of GNU Emacs
(Transcript of Richard Stallman's Speech, 28 Oct 2002, at the International Lisp Conference).

Since none of my usual speeches have anything to do with Lisp, none of them were appropriate for today. So I'm going to have to wing it. Since I've done enough things in my career connected with Lisp I should be able to say something interesting.

My first experience with Lisp was when I read the Lisp 1.5 manual in high school. That's when I had my mind blown by the idea that there could be a computer language like that. The first time I had a chance to do anything with Lisp was when I was a freshman at Harvard and I wrote a Lisp interpreter for the PDP-11. It was a very small machine — it had something like 8k of memory — and I managed to write the interpreter in a thousand instructions. This gave me some room for a little bit of data. That was before I got to see what real software was like, that did real system jobs.

I began doing work on a real Lisp implementation with JonL White once I started working at MIT. I got hired at the Artificial Intelligence Lab not by JonL, but by Russ Noftsker, which was most ironic considering what was to come — he must have really regretted that day.

During the 1970s, before my life became politicized by horrible events, I was just going along making one extension after another for various programs, and most of them did not have anything to do with Lisp. But, along the way, I wrote a text editor, Emacs. The interesting idea about Emacs was that it had a programming language, and the user's editing commands would be written in that interpreted programming language, so that you could load new commands into your editor while you were editing. You could edit the programs you were using and then go on editing with them. So, we had a system that was useful for things other than programming, and yet you could program it while you were using it. I don't know if it was the first one of those, but it certainly was the first editor like that.

This spirit of building up gigantic, complicated programs to use in your own editing, and then exchanging them with other people, fueled the spirit of free-wheeling cooperation that we had at the AI Lab then. The idea was that you could give a copy of any program you had to someone who wanted a copy of it. We shared programs to whomever wanted to use them, they were human knowledge. So even though there was no organized political thought relating the way we shared software to the design of Emacs, I'm convinced that there was a connection between them, an unconscious connection perhaps. I think that it's the nature of the way we lived at the AI Lab that led to Emacs and made it what it was.

The original Emacs did not have Lisp in it. The lower level language, the non-interpreted language — was PDP-10 Assembler. The interpreter we wrote in that actually wasn't written for Emacs, it was written for TECO. It was our text editor, and was an extremely ugly programming language, as ugly as could possibly be. The reason was that it wasn't designed to be a programming language, it was designed to be an editor and command language. There were commands like ‘5l’, meaning ‘move five lines’, or ‘i’ and then a string and then an ESC to insert that string. You would type a string that was a series of commands, which was called a command string. You would end it with ESC ESC, and it would get executed.

Well, people wanted to extend this language with programming facilities, so they added some. For instance, one of the first was a looping construct, which was < >. You would put those around things and it would loop. There were other cryptic commands that could be used to conditionally exit the loop. To make Emacs, we (1) added facilities to have subroutines with names. Before that, it was sort of like Basic, and the subroutines could only have single letters as their names. That was hard to program big programs with, so we added code so they could have longer names. Actually, there were some rather sophisticated facilities; I think that Lisp got its unwind-protect facility from TECO.

We started putting in rather sophisticated facilities, all with the ugliest syntax you could ever think of, and it worked — people were able to write large programs in it anyway. The obvious lesson was that a language like TECO, which wasn't designed to be a programming language, was the wrong way to go. The language that you build your extensions on shouldn't be thought of as a programming language in afterthought; it should be designed as a programming language. In fact, we discovered that the best programming language for that purpose was Lisp.

It was Bernie Greenberg, who discovered that it was (2). He wrote a version of Emacs in Multics MacLisp, and he wrote his commands in MacLisp in a straightforward fashion. The editor itself was written entirely in Lisp. Multics Emacs proved to be a great success — programming new editing commands was so convenient that even the secretaries in his office started learning how to use it. They used a manual someone had written which showed how to extend Emacs, but didn't say it was a programming. So the secretaries, who believed they couldn't do programming, weren't scared off. They read the manual, discovered they could do useful things and they learned to program.

So Bernie saw that an application — a program that does something useful for you — which has Lisp inside it and which you could extend by rewriting the Lisp programs, is actually a very good way for people to learn programming. It gives them a chance to write small programs that are useful for them, which in most arenas you can't possibly do. They can get encouragement for their own practical use — at the stage where it's the hardest — where they don't believe they can program, until they get to the point where they are programmers.

At that point, people began to wonder how they could get something like this on a platform where they didn't have full service Lisp implementation. Multics MacLisp had a compiler as well as an interpreter — it was a full-fledged Lisp system — but people wanted to implement something like that on other systems where they had not already written a Lisp compiler. Well, if you didn't have the Lisp compiler you couldn't write the whole editor in Lisp — it would be too slow, especially redisplay, if it had to run interpreted Lisp. So we developed a hybrid technique. The idea was to write a Lisp interpreter and the lower level parts of the editor together, so that parts of the editor were built-in Lisp facilities. Those would be whatever parts we felt we had to optimize. This was a technique that we had already consciously practiced in the original Emacs, because there were certain fairly high level features which we re-implemented in machine language, making them into TECO primitives. For instance, there was a TECO primitive to fill a paragraph (actually, to do most of the work of filling a paragraph, because some of the less time-consuming parts of the job would be done at the higher level by a TECO program). You could do the whole job by writing a TECO program, but that was too slow, so we optimized it by putting part of it in machine language. We used the same idea here (in the hybrid technique), that most of the editor would be written in Lisp, but certain parts of it that had to run particularly fast would be written at a lower level.

Therefore, when I wrote my second implementation of Emacs, I followed the same kind of design. The low level language was not machine language anymore, it was C. C was a good, efficient language for portable programs to run in a Unix-like operating system. There was a Lisp interpreter, but I implemented facilities for special purpose editing jobs directly in C — manipulating editor buffers, inserting leading text, reading and writing files, redisplaying the buffer on the screen, managing editor windows.

Now, this was not the first Emacs that was written in C and ran on Unix. The first was written by James Gosling, and was referred to as GosMacs. A strange thing happened with him. In the beginning, he seemed to be influenced by the same spirit of sharing and cooperation of the original Emacs. I first released the original Emacs to people at MIT. Someone wanted to port it to run on Twenex — it originally only ran on the Incompatible Timesharing System we used at MIT. They ported it to Twenex, which meant that there were a few hundred installations around the world that could potentially use it. We started distributing it to them, with the rule that “you had to send back all of your improvements” so we could all benefit. No one ever tried to enforce that, but as far as I know people did cooperate.

Gosling did, at first, seem to participate in this spirit. He wrote in a manual that he called the program Emacs hoping that others in the community would improve it until it was worthy of that name. That's the right approach to take towards a community — to ask them to join in and make the program better. But after that he seemed to change the spirit, and sold it to a company.

At that time I was working on the GNU system (a free software Unix-like operating system that many people erroneously call “Linux”). There was no free software Emacs editor that ran on Unix. I did, however, have a friend who had participated in developing Gosling's Emacs. Gosling had given him, by email, permission to distribute his own version. He proposed to me that I use that version. Then I discovered that Gosling's Emacs did not have a real Lisp. It had a programming language that was known as ‘mocklisp’, which looks syntactically like Lisp, but didn't have the data structures of Lisp. So programs were not data, and vital elements of Lisp were missing. Its data structures were strings, numbers and a few other specialized things.

I concluded I couldn't use it and had to replace it all, the first step of which was to write an actual Lisp interpreter. I gradually adapted every part of the editor based on real Lisp data structures, rather than ad hoc data structures, making the data structures of the internals of the editor exposable and manipulable by the user's Lisp programs.

The one exception was redisplay. For a long time, redisplay was sort of an alternate world. The editor would enter the world of redisplay and things would go on with very special data structures that were not safe for garbage collection, not safe for interruption, and you couldn't run any Lisp programs during that. We've changed that since — it's now possible to run Lisp code during redisplay. It's quite a convenient thing.

This second Emacs program was ‘free software’ in the modern sense of the term — it was part of an explicit political campaign to make software free. The essence of this campaign was that everybody should be free to do the things we did in the old days at MIT, working together on software and working with whomever wanted to work with us. That is the basis for the free software movement — the experience I had, the life that I've lived at the MIT AI lab — to be working on human knowledge, and not be standing in the way of anybody's further using and further disseminating human knowledge.

At the time, you could make a computer that was about the same price range as other computers that weren't meant for Lisp, except that it would run Lisp much faster than they would, and with full type checking in every operation as well. Ordinary computers typically forced you to choose between execution speed and good typechecking. So yes, you could have a Lisp compiler and run your programs fast, but when they tried to take car of a number, it got nonsensical results and eventually crashed at some point.

The Lisp machine was able to execute instructions about as fast as those other machines, but each instruction — a car instruction would do data typechecking — so when you tried to get the car of a number in a compiled program, it would give you an immediate error. We built the machine and had a Lisp operating system for it. It was written almost entirely in Lisp, the only exceptions being parts written in the microcode. People became interested in manufacturing them, which meant they should start a company.

There were two different ideas about what this company should be like. Greenblatt wanted to start what he called a “hacker” company. This meant it would be a company run by hackers and would operate in a way conducive to hackers. Another goal was to maintain the AI Lab culture (3). Unfortunately, Greenblatt didn't have any business experience, so other people in the Lisp machine group said they doubted whether he could succeed. They thought that his plan to avoid outside investment wouldn't work.

Why did he want to avoid outside investment? Because when a company has outside investors, they take control and they don't let you have any scruples. And eventually, if you have any scruples, they also replace you as the manager.

So Greenblatt had the idea that he would find a customer who would pay in advance to buy the parts. They would build machines and deliver them; with profits from those parts, they would then be able to buy parts for a few more machines, sell those and then buy parts for a larger number of machines, and so on. The other people in the group thought that this couldn't possibly work.

Greenblatt then recruited Russell Noftsker, the man who had hired me, who had subsequently left the AI Lab and created a successful company. Russell was believed to have an aptitude for business. He demonstrated this aptitude for business by saying to the other people in the group, “Let's ditch Greenblatt, forget his ideas, and we'll make another company.” Stabbing in the back, clearly a real businessman. Those people decided they would form a company called Symbolics. They would get outside investment, not have scruples, and do everything possible to win.

But Greenblatt didn't give up. He and the few people loyal to him decided to start Lisp Machines Inc. anyway and go ahead with their plans. And what do you know, they succeeded! They got the first customer and were paid in advance. They built machines and sold them, and built more machines and more machines. They actually succeeded even though they didn't have the help of most of the people in the group. Symbolics also got off to a successful start, so you had two competing Lisp machine companies. When Symbolics saw that LMI was not going to fall flat on its face, they started looking for ways to destroy it.

Thus, the abandonment of our lab was followed by “war” in our lab. The abandonment happened when Symbolics hired away all the hackers, except me and the few who worked at LMI part-time. Then they invoked a rule and eliminated people who worked part-time for MIT, so they had to leave entirely, which left only me. The AI lab was now helpless. And MIT had made a very foolish arrangement with these two companies. It was a three-way contract where both companies licensed the use of Lisp machine system sources. These companies were required to let MIT use their changes. But it didn't say in the contract that MIT was entitled to put them into the MIT Lisp machine systems that both companies had licensed. Nobody had envisioned that the AI lab's hacker group would be wiped out, but it was.

So Symbolics came up with a plan (4). They said to the lab, “We will continue making our changes to the system available for you to use, but you can't put it into the MIT Lisp machine system. Instead, we'll give you access to Symbolics' Lisp machine system, and you can run it, but that's all you can do.”

This, in effect, meant that they demanded that we had to choose a side, and use either the MIT version of the system or the Symbolics version. Whichever choice we made determined which system our improvements went to. If we worked on and improved the Symbolics version, we would be supporting Symbolics alone. If we used and improved the MIT version of the system, we would be doing work available to both companies, but Symbolics saw that we would be supporting LMI because we would be helping them continue to exist. So we were not allowed to be neutral anymore.

Up until that point, I hadn't taken the side of either company, although it made me miserable to see what had happened to our community and the software. But now, Symbolics had forced the issue. So, in an effort to help keep Lisp Machines Inc. going (5) — I began duplicating all of the improvements Symbolics had made to the Lisp machine system. I wrote the equivalent improvements again myself (i.e., the code was my own).

After a while (6), I came to the conclusion that it would be best if I didn't even look at their code. When they made a beta announcement that gave the release notes, I would see what the features were and then implement them. By the time they had a real release, I did too.

In this way, for two years, I prevented them from wiping out Lisp Machines Incorporated, and the two companies went on. But, I didn't want to spend years and years punishing someone, just thwarting an evil deed. I figured they had been punished pretty thoroughly because they were stuck with competition that was not leaving or going to disappear (7). Meanwhile, it was time to start building a new community to replace the one that their actions and others had wiped out.

The Lisp community in the 70s was not limited to the MIT AI Lab, and the hackers were not all at MIT. The war that Symbolics started was what wiped out MIT, but there were other events going on then. There were people giving up on cooperation, and together this wiped out the community and there wasn't much left.

Once I stopped punishing Symbolics, I had to figure out what to do next. I had to make a free operating system, that was clear — the only way that people could work together and share was with a free operating system.

At first, I thought of making a Lisp-based system, but I realized that wouldn't be a good idea technically. To have something like the Lisp machine system, you needed special purpose microcode. That's what made it possible to run programs as fast as other computers would run their programs and still get the benefit of typechecking. Without that, you would be reduced to something like the Lisp compilers for other machines. The programs would be faster, but unstable. Now that's okay if you're running one program on a timesharing system — if one program crashes, that's not a disaster, that's something your program occasionally does. But that didn't make it good for writing the operating system in, so I rejected the idea of making a system like the Lisp machine.

I decided instead to make a Unix-like operating system that would have Lisp implementations to run as user programs. The kernel wouldn't be written in Lisp, but we'd have Lisp. So the development of that operating system, the GNU operating system, is what led me to write the GNU Emacs. In doing this, I aimed to make the absolute minimal possible Lisp implementation. The size of the programs was a tremendous concern.

There were people in those days, in 1985, who had one-megabyte machines without virtual memory. They wanted to be able to use GNU Emacs. This meant I had to keep the program as small as possible.

For instance, at the time the only looping construct was ‘while’, which was extremely simple. There was no way to break out of the ‘while’ statement, you just had to do a catch and a throw, or test a variable that ran the loop. That shows how far I was pushing to keep things small. We didn't have ‘caar’ and ‘cadr’ and so on; “squeeze out everything possible” was the spirit of GNU Emacs, the spirit of Emacs Lisp, from the beginning.

Obviously, machines are bigger now, and we don't do it that way any more. We put in ‘caar’ and ‘cadr’ and so on, and we might put in another looping construct one of these days. We're willing to extend it some now, but we don't want to extend it to the level of common Lisp. I implemented Common Lisp once on the Lisp machine, and I'm not all that happy with it. One thing I don't like terribly much is keyword arguments (8). They don't seem quite Lispy to me; I'll do it sometimes but I minimize the times when I do that.

That was not the end of the GNU projects involved with Lisp. Later on around 1995, we were looking into starting a graphical desktop project. It was clear that for the programs on the desktop, we wanted a programming language to write a lot of it in to make it easily extensible, like the editor. The question was what it should be.

At the time, TCL was being pushed heavily for this purpose. I had a very low opinion of TCL, basically because it wasn't Lisp. It looks a tiny bit like Lisp, but semantically it isn't, and it's not as clean. Then someone showed me an ad where Sun was trying to hire somebody to work on TCL to make it the “de-facto standard extension language” of the world. And I thought, “We've got to stop that from happening.” So we started to make Scheme the standard extensibility language for GNU. Not Common Lisp, because it was too large. The idea was that we would have a Scheme interpreter designed to be linked into applications in the same way TCL was linked into applications. We would then recommend that as the preferred extensibility package for all GNU programs.

There's an interesting benefit you can get from using such a powerful language as a version of Lisp as your primary extensibility language. You can implement other languages by translating them into your primary language. If your primary language is TCL, you can't very easily implement Lisp by translating it into TCL. But if your primary language is Lisp, it's not that hard to implement other things by translating them. Our idea was that if each extensible application supported Scheme, you could write an implementation of TCL or Python or Perl in Scheme that translates that program into Scheme. Then you could load that into any application and customize it in your favorite language and it would work with other customizations as well.

As long as the extensibility languages are weak, the users have to use only the language you provided them. Which means that people who love any given language have to compete for the choice of the developers of applications — saying “Please, application developer, put my language into your application, not his language.” Then the users get no choices at all — whichever application they're using comes with one language and they're stuck with [that language]. But when you have a powerful language that can implement others by translating into it, then you give the user a choice of language and we don't have to have a language war anymore. That's what we're hoping ‘Guile’, our scheme interpreter, will do. We had a person working last summer finishing up a translator from Python to Scheme. I don't know if it's entirely finished yet, but for anyone interested in this project, please get in touch. So that's the plan we have for the future.

I haven't been speaking about free software, but let me briefly tell you a little bit about what that means. Free software does not refer to price; it doesn't mean that you get it for free. (You may have paid for a copy, or gotten a copy gratis.) It means that you have freedom as a user. The crucial thing is that you are free to run the program, free to study what it does, free to change it to suit your needs, free to redistribute the copies of others and free to publish improved, extended versions. This is what free software means. If you are using a non-free program, you have lost crucial freedom, so don't ever do that.

The purpose of the GNU project is to make it easier for people to reject freedom-trampling, user-dominating, non-free software by providing free software to replace it. For those who don't have the moral courage to reject the non-free software, when that means some practical inconvenience, what we try to do is give a free alternative so that you can move to freedom with less of a mess and less of a sacrifice in practical terms. The less sacrifice the better. We want to make it easier for you to live in freedom, to cooperate.

This is a matter of the freedom to cooperate. We're used to thinking of freedom and cooperation with society as if they are opposites. But here they're on the same side. With free software you are free to cooperate with other people as well as free to help yourself. With non-free software, somebody is dominating you and keeping people divided. You're not allowed to share with them, you're not free to cooperate or help society, anymore than you're free to help yourself. Divided and helpless is the state of users using non-free software.

We've produced a tremendous range of free software. We've done what people said we could never do; we have two operating systems of free software. We have many applications and we obviously have a lot farther to go. So we need your help. I would like to ask you to volunteer for the GNU project; help us develop free software for more jobs. Take a look at http://www.gnu.org/help to find suggestions for how to help. If you want to order things, there's a link to that from the home page. If you want to read about philosophical issues, look in /philosophy. If you're looking for free software to use, look in /directory, which lists about 1900 packages now (which is a fraction of all the free software out there). Please write more and contribute to us. My book of essays, “Free Software and Free Society”, is on sale and can be purchased at www.gnu.org. Happy hacking!

Guy Steele designed the original symmetrical Emacs command set; then he and I began implementing Emacs (on top of TECO), but after one long joint development session, Steele began drifting away, so I finished Emacs. Others particularly including Eugene C. Cicciarelli and Mike McMahon contributed substantially later on.
Bernie Greenberg says that Dan Weinreb's implementation of Emacs for the Lisp Machine came before Greenberg's implementation for Multics. I apologize for the mistake.
Greenblatt's plan, as I understood it, was to hire lab people part time, so that they could continue working at the AI Lab. Symbolics hired them full time instead, so they stopped working at MIT.
The background of this plan, which I did not state explicitly in the talk, is that during an initial period the ex-AI-Lab hackers, whether at Symbolics or LMI, continued contributing their changes to the MIT Lisp Machine system — even though the contract did not require this. Symbolics' plan was to rupture this cooperation unilaterally.
It was not that I cared particularly about the fate of LMI, but rather I did not want to let Symbolics gain through its aggression against the AI Lab.
This statement has been misconstrued as saying that I never, ever looked at Symbolics' code. Actually it says I did look, at first. The Symbolics source code was available at MIT, where I was entitled to read it, and at first that's how I found out about their changes.
But that meant I had to make a special effort to solve each problem differently, in order to avoid copying Symbolics code. After a while, I concluded it was better not to even look. That way I could write code in whatever way was best, without concern for what might be in Symbolics' code.

Symbolics at one point protested to MIT that my work, by thwarting their plan, had cost Symbolics a million dollars.
I don't mind if a very complex and heavyweight function takes keyword arguments. What bothers me is making simple basic functions such as “member” use them.


https://www.gnu.org/philosophy/15-years-of-free-software.html
15 Years of Free Software
by Richard M. Stallman

It is now just over 15 years since the beginning of the Free Software Movement and the GNU Project. We have come a long way.

In 1984, it was impossible to use a modern computer without installing a proprietary operating system, which you would have to obtain under a restrictive license. No one was allowed to share software freely with fellow computer users, and hardly anyone could change software to fit his or her own needs. The owners of software had erected walls to divide us from each other.

The GNU Project was founded to change all that. Its first goal: to develop a Unix-compatible portable operating system that would be 100% free software. Not 95% free, not 99.5%, but 100%—so that users would be free to redistribute the whole system, and free to change and contribute to any part of it. The name of the system, GNU, is a recursive acronym meaning “GNU's Not Unix”—a way of paying tribute to the technical ideas of Unix, while at the same time saying that GNU is something different. Technically, GNU is like Unix. But unlike Unix, GNU gives its users freedom.

It took many years of work, by hundreds of programmers, to develop this operating system. Some were paid by the Free Software Foundation and by free software companies; most were volunteers. A few have become famous; most are known mainly within their profession, by other hackers who use or work on their code. All together have helped to liberate the potential of the computer network for all humanity.

In 1991, the last major essential component of a Unix-like system was developed: Linux, the free kernel written by Linus Torvalds. Today, the combination of GNU and Linux is used by millions of people around the world, and its popularity is growing. This month, we announced release 1.0 of GNOME, the GNU graphical desktop, which we hope will make the GNU/Linux system as easy to use as any other operating system.

But our freedom is not permanently assured. The world does not stand still, and we cannot count on having freedom five years from now, just because we have it today. Free software faces difficult challenges and dangers. It will take determined efforts to preserve our freedom, just as it took to obtain freedom in the first place. Meanwhile, the operating system is just the beginning—now we need to add free applications to handle the whole range of jobs that users want to do.

In future columns, I will be writing about the specific challenges facing the free software community, and other issues affecting freedom for computer users, as well as developments affecting the GNU/Linux operating system.


https://www.gnu.org/gnu/why-programs-should-be-shared.html
Why Programs Should be Shared
by Richard Stallman

Richard Stallman wrote this text, which was found in a file dated May 1983, though it is not clear whether it was written then or earlier. In May 1983 he was privately considering plans to develop a free operating system, but he may not yet have decided to make it a Unix-like system rather than something like the MIT Lisp Machine.

He had not yet conceptually distinguished the two meanings of “free;” this message is formulated in terms of gratis copies, but take for granted that this means users also have freedom.

Five years ago one could take for granted that any useful program written at SAIL, MIT, CMU, etc. would be shared. Since then, these universities have started acting just like software houses—everything useful will be sold for an arm and a leg (usually after being written at gov't expense).

People find all sorts of excuses why it's harmful to give away software. These supposed problems never bothered us back when we wanted to share, and haven't affected EMACS, so I suspect they are bogus.

For example, people say that companies will “steal” it and sell it. If so, that would be no worse than Stanford selling it! At least people would have the choice of getting a free copy. Users want to buy maintained software? Then let people sell service contracts—but give the software itself free.

I think I can dispose of any reasons you may think exist for not sharing software. But more important is the reason why we should share:

We would get more done with the same amount of work, if artificial obstacles were removed. And we would feel more in harmony with everyone else.

Sharing software is the form that scientific cooperation takes in the field of computer science. Universities used to defend the principle of scientific cooperation. Is it right for them to throw it over for profit?

Should we let them?

Right now graduate students here are working on programming projects that are specifically intended for sale. But if we create a climate of opinion like that of five years ago, the university wouldn't dare to do this. And if you start sharing, other people might start sharing with you.

So let's start sharing again.


https://www.gnu.org/gnu/yes-give-it-away.html
Yes, Give It Away
by Richard Stallman

Richard Stallman wrote this text, which was found in a file dated May 1983, though it is not clear whether it was written then or earlier. In May 1983 he was privately considering plans to develop a free operating system, but he may not yet have decided to make it a Unix-like system rather than something like the MIT Lisp Machine.

He had not yet conceptually distinguished the two meanings of “free;” this message is formulated in terms of gratis copies, but take for granted that this means users also have freedom.

One of the important reasons for giving software away free is to enable the users to change it. This allows them to make better use of it, and also encourages and enables them to contribute to the effort. Furthermore, they develop self-reliance, confidence, and a sense of responsibility.

I've often heard that Americans will think something is worthless if it's free. It might be true, but it's not rational. People have a right to be neurotic but we should not encourage this. In the mean time, giving software away is not “treating it as worthless” just because some masochists might conclude it was worthless.

Users would not change software if it were worthless; rather, because it is worth more to them as changed than before. Some central maintenance is also useful, but there are other ways to provide for this aside from hassling the users.

I have a lot of experience with sharing software and having the users change it. I find that

there is little tendency to believe EMACS is worthless
users change EMACS a lot
users' changes contribute to EMACS development
centralized maintenance of EMACS continues
I approached users in a non-manipulative cooperative spirit, and they reacted enthusiastically and cooperatively. When told that restrictions are being imposed to trick their neuroses or because they are assumed in advance to be incompetent, they feel justifiable resentment. They also tend to become incompetent and neurotic as a result.


https://www.gnu.org/gnu/linux-and-gnu.html
Linux and the GNU System
by Richard Stallman

For more information see also the GNU/Linux FAQ, and Why GNU/Linux?

Many computer users run a modified version of the GNU system every day, without realizing it. Through a peculiar turn of events, the version of GNU which is widely used today is often called “Linux”, and many of its users are not aware that it is basically the GNU system, developed by the GNU Project.

There really is a Linux, and these people are using it, but it is just a part of the system they use. Linux is the kernel: the program in the system that allocates the machine's resources to the other programs that you run. The kernel is an essential part of an operating system, but useless by itself; it can only function in the context of a complete operating system. Linux is normally used in combination with the GNU operating system: the whole system is basically GNU with Linux added, or GNU/Linux. All the so-called “Linux” distributions are really distributions of GNU/Linux.

Many users do not understand the difference between the kernel, which is Linux, and the whole system, which they also call “Linux”. The ambiguous use of the name doesn't help people understand. These users often think that Linus Torvalds developed the whole operating system in 1991, with a bit of help.

Programmers generally know that Linux is a kernel. But since they have generally heard the whole system called “Linux” as well, they often envisage a history that would justify naming the whole system after the kernel. For example, many believe that once Linus Torvalds finished writing Linux, the kernel, its users looked around for other free software to go with it, and found that (for no particular reason) most everything necessary to make a Unix-like system was already available.

What they found was no accident—it was the not-quite-complete GNU system. The available free software added up to a complete system because the GNU Project had been working since 1984 to make one. In the GNU Manifesto we set forth the goal of developing a free Unix-like system, called GNU. The Initial Announcement of the GNU Project also outlines some of the original plans for the GNU system. By the time Linux was started, GNU was almost finished.

Most free software projects have the goal of developing a particular program for a particular job. For example, Linus Torvalds set out to write a Unix-like kernel (Linux); Donald Knuth set out to write a text formatter (TeX); Bob Scheifler set out to develop a window system (the X Window System). It's natural to measure the contribution of this kind of project by specific programs that came from the project.

If we tried to measure the GNU Project's contribution in this way, what would we conclude? One CD-ROM vendor found that in their “Linux distribution”, GNU software was the largest single contingent, around 28% of the total source code, and this included some of the essential major components without which there could be no system. Linux itself was about 3%. (The proportions in 2008 are similar: in the “main” repository of gNewSense, Linux is 1.5% and GNU packages are 15%.) So if you were going to pick a name for the system based on who wrote the programs in the system, the most appropriate single choice would be “GNU”.

But that is not the deepest way to consider the question. The GNU Project was not, is not, a project to develop specific software packages. It was not a project to develop a C compiler, although we did that. It was not a project to develop a text editor, although we developed one. The GNU Project set out to develop a complete free Unix-like system: GNU.

Many people have made major contributions to the free software in the system, and they all deserve credit for their software. But the reason it is an integrated system—and not just a collection of useful programs—is because the GNU Project set out to make it one. We made a list of the programs needed to make a complete free system, and we systematically found, wrote, or found people to write everything on the list. We wrote essential but unexciting (1) components because you can't have a system without them. Some of our system components, the programming tools, became popular on their own among programmers, but we wrote many components that are not tools (2). We even developed a chess game, GNU Chess, because a complete system needs games too.

By the early 90s we had put together the whole system aside from the kernel. We had also started a kernel, the GNU Hurd, which runs on top of Mach. Developing this kernel has been a lot harder than we expected; the GNU Hurd started working reliably in 2001, but it is a long way from being ready for people to use in general.

Fortunately, we didn't have to wait for the Hurd, because of Linux. Once Torvalds freed Linux in 1992, it fit into the last major gap in the GNU system. People could then combine Linux with the GNU system to make a complete free system — a version of the GNU system which also contained Linux. The GNU/Linux system, in other words.

Making them work well together was not a trivial job. Some GNU components(3) needed substantial change to work with Linux. Integrating a complete system as a distribution that would work “out of the box” was a big job, too. It required addressing the issue of how to install and boot the system—a problem we had not tackled, because we hadn't yet reached that point. Thus, the people who developed the various system distributions did a lot of essential work. But it was work that, in the nature of things, was surely going to be done by someone.

The GNU Project supports GNU/Linux systems as well as the GNU system. The FSF funded the rewriting of the Linux-related extensions to the GNU C library, so that now they are well integrated, and the newest GNU/Linux systems use the current library release with no changes. The FSF also funded an early stage of the development of Debian GNU/Linux.

Today there are many different variants of the GNU/Linux system (often called “distros”). Most of them include nonfree programs—their developers follow the “open source” philosophy associated with Linux rather than the “free software” philosophy of GNU. But there are also completely free GNU/Linux distros. The FSF supports computer facilities for a few of them.

Making a free GNU/Linux distribution is not just a matter of eliminating various nonfree programs. Nowadays, the usual version of Linux contains nonfree programs too. These programs are intended to be loaded into I/O devices when the system starts, and they are included, as long series of numbers, in the "source code" of Linux. Thus, maintaining free GNU/Linux distributions now entails maintaining a free version of Linux too.

Whether you use GNU/Linux or not, please don't confuse the public by using the name “Linux” ambiguously. Linux is the kernel, one of the essential major components of the system. The system as a whole is basically the GNU system, with Linux added. When you're talking about this combination, please call it “GNU/Linux”.

If you want to make a link on “GNU/Linux” for further reference, this page and http://www.gnu.org/gnu/the-gnu-project.html are good choices. If you mention Linux, the kernel, and want to add a link for further reference, http://foldoc.org/linux is a good URL to use.

Postscripts
Aside from GNU, one other project has independently produced a free Unix-like operating system. This system is known as BSD, and it was developed at UC Berkeley. It was nonfree in the 80s, but became free in the early 90s. A free operating system that exists today(4) is almost certainly either a variant of the GNU system, or a kind of BSD system.

People sometimes ask whether BSD too is a version of GNU, like GNU/Linux. The BSD developers were inspired to make their code free software by the example of the GNU Project, and explicit appeals from GNU activists helped persuade them, but the code had little overlap with GNU. BSD systems today use some GNU programs, just as the GNU system and its variants use some BSD programs; however, taken as wholes, they are two different systems that evolved separately. The BSD developers did not write a kernel and add it to the GNU system, and a name like GNU/BSD would not fit the situation.(5)

Notes:
These unexciting but essential components include the GNU assembler (GAS) and the linker (GLD), both are now part of the GNU Binutils package, GNU tar, and many more.
For instance, The Bourne Again SHell (BASH), the PostScript interpreter Ghostscript, and the GNU C library are not programming tools. Neither are GNUCash, GNOME, and GNU Chess.
For instance, the GNU C library.
Since that was written, a nearly-all-free Windows-like system has been developed, but technically it is not at all like GNU or Unix, so it doesn't really affect this issue. Most of the kernel of Solaris has been made free, but if you wanted to make a free system out of that, aside from replacing the missing parts of the kernel, you would also need to put it into GNU or BSD.
On the other hand, in the years since this article was written, the GNU C Library has been ported to several versions of the BSD kernel, which made it straightforward to combine the GNU system with that kernel. Just as with GNU/Linux, these are indeed variants of GNU, and are therefore called, for instance, GNU/kFreeBSD and GNU/kNetBSD depending on the kernel of the system. Ordinary users on typical desktops can hardly distinguish between GNU/Linux and GNU/*BSD.


https://www.gnu.org/gnu/why-gnu-linux.html
What's in a Name?
by Richard Stallman

To learn more about this issue, you can read our GNU/Linux FAQ, our page on Linux and the GNU Project, which gives a history of the GNU/Linux system as it relates to this issue of naming, and our page on GNU Users Who Have Never Heard of GNU.

Names convey meanings; our choice of names determines the meaning of what we say. An inappropriate name gives people the wrong idea. A rose by any other name would smell as sweet—but if you call it a pen, people will be rather disappointed when they try to write with it. And if you call pens “roses”, people may not realize what they are good for. If you call our operating system Linux, that conveys a mistaken idea of the system's origin, history, and purpose. If you call it GNU/Linux, that conveys (though not in detail) an accurate idea.

Does this really matter for our community? Is it important whether people know the system's origin, history, and purpose? Yes—because people who forget history are often condemned to repeat it. The Free World that has developed around GNU/Linux is not guaranteed to survive; the problems that led us to develop GNU are not completely eradicated, and they threaten to come back.

When I explain why it's appropriate to call the operating system GNU/Linux rather than Linux, people sometimes respond this way:

Granted that the GNU Project deserves credit for this work, is it really worth a fuss when people don't give credit? Isn't the important thing that the job was done, not who did it? You ought to relax, take pride in the job well done, and not worry about the credit.

This would be wise advice, if only the situation were like that—if the job were done and it were time to relax. If only that were true! But challenges abound, and this is no time to take the future for granted. Our community's strength rests on commitment to freedom and cooperation. Using the name GNU/Linux is a way for people to remind themselves and inform others of these goals.

It is possible to write good free software without thinking of GNU; much good work has been done in the name of Linux also. But the term “Linux” has been associated ever since it was first coined with a philosophy that does not make a commitment to the freedom to cooperate. As the name is increasingly used by business, we will have even more trouble making it connect with community spirit.

A great challenge to the future of free software comes from the tendency of the “Linux” distribution companies to add nonfree software to GNU/Linux in the name of convenience and power. All the major commercial distribution developers do this; none limits itself to free software. Most of them do not clearly identify the nonfree packages in their distributions. Many even develop nonfree software and add it to the system. Some outrageously advertise “Linux” systems that are “licensed per seat”, which give the user as much freedom as Microsoft Windows.

People try to justify adding nonfree software in the name of the “popularity of Linux”—in effect, valuing popularity above freedom. Sometimes this is openly admitted. For instance, Wired Magazine said that Robert McMillan, editor of Linux Magazine, “feels that the move toward open source software should be fueled by technical, rather than political, decisions.” And Caldera's CEO openly urged users to drop the goal of freedom and work instead for the “popularity of Linux”.

Adding nonfree software to the GNU/Linux system may increase the popularity, if by popularity we mean the number of people using some of GNU/Linux in combination with nonfree software. But at the same time, it implicitly encourages the community to accept nonfree software as a good thing, and forget the goal of freedom. It is not good to drive faster if you can't stay on the road.

When the nonfree “add-on” is a library or programming tool, it can become a trap for free software developers. When they write free software that depends on the nonfree package, their software cannot be part of a completely free system. Motif and Qt trapped large amounts of free software in this way in the past, creating problems whose solutions took years. Motif remained somewhat of a problem until it became obsolete and was no longer used. Later, Sun's nonfree Java implementation had a similar effect: the Java Trap, fortunately now mostly corrected.

If our community keeps moving in this direction, it could redirect the future of GNU/Linux into a mosaic of free and nonfree components. Five years from now, we will surely still have plenty of free software; but if we are not careful, it will hardly be usable without the nonfree software that users expect to find with it. If this happens, our campaign for freedom will have failed.

If releasing free alternatives were simply a matter of programming, solving future problems might become easier as our community's development resources increase. But we face obstacles that threaten to make this harder: laws that prohibit free software. As software patents mount up, and as laws like the DMCA are used to prohibit the development of free software for important jobs such as viewing a DVD or listening to a RealAudio stream, we will find ourselves with no clear way to fight the patented and secret data formats except to reject the nonfree programs that use them.

Meeting these challenges will require many different kinds of effort. But what we need above all, to confront any kind of challenge, is to remember the goal of freedom to cooperate. We can't expect a mere desire for powerful, reliable software to motivate people to make great efforts. We need the kind of determination that people have when they fight for their freedom and their community—determination to keep on for years and not give up.

In our community, this goal and this determination emanate mainly from the GNU Project. We're the ones who talk about freedom and community as something to stand firm for; the organizations that speak of “Linux” normally don't say this. The magazines about “Linux” are typically full of ads for nonfree software; the companies that package “Linux” add nonfree software to the system; other companies “support Linux” by developing nonfree applications to run on GNU/Linux; the user groups for “Linux” typically invite salesman to present those applications. The main place people in our community are likely to come across the idea of freedom and determination is in the GNU Project.

But when people come across it, will they feel it relates to them?

People who know they are using a system that came out of the GNU Project can see a direct relationship between themselves and GNU. They won't automatically agree with our philosophy, but at least they will see a reason to think seriously about it. In contrast, people who consider themselves “Linux users”, and believe that the GNU Project “developed tools which proved to be useful in Linux”, typically perceive only an indirect relationship between GNU and themselves. They may just ignore the GNU philosophy when they come across it.

The GNU Project is idealistic, and anyone encouraging idealism today faces a great obstacle: the prevailing ideology encourages people to dismiss idealism as “impractical”. Our idealism has been extremely practical: it is the reason we have a free GNU/Linux operating system. People who love this system ought to know that it is our idealism made real.

If “the job” really were done, if there were nothing at stake except credit, perhaps it would be wiser to let the matter drop. But we are not in that position. To inspire people to do the work that needs to be done, we need to be recognized for what we have already done. Please help us, by calling the operating system GNU/Linux.

This essay is published in Free Software, Free Society: The Selected Essays of Richard M. Stallman.


https://www.gnu.org/gnu/gnu-users-never-heard-of-gnu.html
GNU Users Who Have Never Heard of GNU
by Richard Stallman

To learn more about this issue, you can also read our GNU/Linux FAQ, our page on Why GNU/Linux? and our page on Linux and the GNU Project.

Most people have never heard of GNU. Even most of the people who use the GNU system have never heard of GNU, since so many people and companies teach them to call it “Linux”. Indeed, GNU users often say they are “running Linux”, which is like saying you are “driving your carburetor” or “driving your transmission”.

Nonetheless, those who know about GNU associate it with the ideals of freedom of the free software movement. That association is no accident; the motive for developing GNU was specifically to make it possible to use a computer and have freedom.

A person seeing the name “GNU” for the first time in “GNU/Linux” won't immediately know what it represents, but has come one step closer to finding out. The association between the name GNU and our goals of freedom and social solidarity exists in the minds of hundreds of thousands of GNU/Linux users that do know about GNU. It exists in gnu.org and in Wikipedia. It exists around the web; if these users search for GNU, they will find the ideas GNU stands for.

If they don't search, they may encounter them anyway. The “open source” rhetoric tends to lead people's attention away from issues of users' freedom, but not totally; there is still discussion of GNU and free software, and people have some chance of coming across it. When that happens, they are more likely to pay attention to information about GNU (such as that it's the work of a campaign for freedom and community) if they know they are users of the GNU system.

Over time, calling the system “GNU/Linux” spreads awareness of the ideals of freedom for which we developed the GNU system. It is also useful as a reminder for people in our community who know about these ideals, in a world where much of discussion of free software takes a totally practical (and thus amoral) approach. When we ask you to call the system “GNU/Linux”, we are asking you to help in making the public aware of the free software ideals.


https://www.gnu.org/gnu/gnu-linux-faq.html
GNU/Linux FAQ by Richard Stallman
To learn more about this issue, you can also read our page on Linux and the GNU Project, our page on Why GNU/Linux? and our page on GNU Users Who Have Never Heard of GNU.

When people see that we use and recommend the name GNU/Linux for a system that many others call just “Linux”, they ask many questions. Here are common questions, and our answers.

Why do you call the system we use GNU/Linux and not Linux?
Why is the name important?
What is the real relationship between GNU and Linux?
How did it come about that most people call the system “Linux”?
Should we always say “GNU/Linux” instead of “Linux”?
Would Linux have achieved the same success if there had been no GNU?
Wouldn't it be better for the community if you did not divide people with this request?
Doesn't the GNU project support an individual's free speech rights to call the system by any name that individual chooses?
Since everyone knows the role of GNU in developing the system, doesn't the “GNU/” in the name go without saying?
Since I know the role of GNU in this system, why does it matter what name I use?
Isn't shortening “GNU/Linux” to “Linux” just like shortening “Microsoft Windows” to “Windows”?
Isn't GNU a collection of programming tools that were included in Linux?
What is the difference between an operating system and a kernel?
The kernel of a system is like the foundation of a house. How can a house be almost complete when it doesn't have a foundation?
Isn't the kernel the brain of the system?
Isn't writing the kernel most of the work in an operating system?
How can GNU be an operating system, if I can't get something called “GNU” and install it?
We're calling the whole system after the kernel, Linux. Isn't it normal to name an operating system after a kernel?
Can another system have “the feel of Linux”?
The problem with “GNU/Linux” is that it is too long. How about recommending a shorter name?
How about calling the system “GliNUx” (instead of “GNU/Linux”)?
The problem with “GNU/Linux” is that it is too long. Why should I go to the trouble of saying “GNU/”?
Unfortunately, “GNU/Linux” is five syllables. People won't use such a long term. Shouldn't you find a shorter one?
Since Linux is a secondary contribution, would it be false to the facts to call the system simply “GNU”?
I would have to pay a fee if I use “Linux” in the name of a product, and that would also apply if I say “GNU/Linux”. Is it wrong if I use “GNU” without “Linux”, to save the fee?
Many other projects contributed to the system as it is today; it includes TeX, X11, Apache, Perl, and many more programs. Don't your arguments imply we have to give them credit too? (But that would lead to a name so long it is absurd.)
Many other projects contributed to the system as it is today, but they don't insist on calling it XYZ/Linux. Why should we treat GNU specially?
GNU is a small fraction of the system nowadays, so why should we mention it?
Many companies contributed to the system as it is today; doesn't that mean we ought to call it GNU/Red Hat/Novell/Linux?
Why do you write “GNU/Linux” instead of “GNU Linux”?
Why “GNU/Linux” rather than “Linux/GNU”?
My distro's developers call it “Foobar Linux”, but that doesn't say anything about what the system consists of. Why shouldn't they call it whatever they like?
My distro is called “Foobar Linux”; doesn't that show it's really Linux?
My distro's official name is “Foobar Linux”; isn't it wrong to call the distro anything but “Foobar Linux”?
Wouldn't it be more effective to ask companies such as Mandrake, Red Hat and IBM to call their distributions “GNU/Linux” rather than asking individuals?
Wouldn't it be better to reserve the name “GNU/Linux” for distributions that are purely free software? After all, that is the ideal of GNU.
Why not make a GNU distribution of Linux (sic) and call that GNU/Linux?
Why not just say “Linux is the GNU kernel” and release some existing version of GNU/Linux under the name “GNU”?
Did the GNU Project condemn and oppose use of Linux in the early days?
Why did you wait so long before asking people to use the name GNU/Linux?
Should the GNU/name convention be applied to all programs that are GPL'ed?
Since much of GNU comes from Unix, shouldn't GNU give credit to Unix by using “Unix” in its name?
Should we say “GNU/BSD” too?
If I install the GNU tools on Windows, does that mean I am running a GNU/Windows system?
Can't Linux be used without GNU?
How much of the GNU system is needed for the system to be GNU/Linux?
Are there complete Linux systems [sic] without GNU?
Is it correct to say “using Linux” if it refers to using GNU/Linux and using Android?
Why not call the system “Linux” anyway, and strengthen Linus Torvalds' role as posterboy for our community?
Isn't it wrong for us to label Linus Torvalds' work as GNU?
Does Linus Torvalds agree that Linux is just the kernel?
Why not finish the GNU Hurd kernel, release the GNU system as a whole, and forget the question of what to call GNU/Linux?
The battle is already lost—society has made its decision and we can't change it, so why even think about it?
Society has made its decision and we can't change it, so what good does it do if I say “GNU/Linux”?
Wouldn't it be better to call the system “Linux” and teach people its real origin with a ten-minute explanation?
Some people laugh at you when you ask them to call the system GNU/Linux. Why do you subject yourself to this treatment?
Some people condemn you when you ask them to call the system GNU/Linux. Don't you lose by alienating them?
Whatever you contributed, is it legitimate to rename the operating system?
Isn't it wrong to force people to call the system “GNU/Linux”?
Why not sue people who call the whole system “Linux”?
Since you objected to the original BSD license's advertising requirement to give credit to the University of California, isn't it hypocritical to demand credit for the GNU project?
Shouldn't you put something in the GNU GPL to require people to call the system “GNU”?
Since you failed to put something in the GNU GPL to require people to call the system “GNU”, you deserve what happened; why are you complaining now?
Wouldn't you be better off not contradicting what so many people believe?
Since many people call it “Linux”, doesn't that make it right?
Isn't it better to call the system by the name most users already know?
Many people care about what's convenient or who's winning, not about arguments of right or wrong. Couldn't you get more of their support by a different road?
Why do you call the system we use GNU/Linux and not Linux? (#why)
Most operating system distributions based on Linux as kernel are basically modified versions of the GNU operating system. We began developing GNU in 1984, years before Linus Torvalds started to write his kernel. Our goal was to develop a complete free operating system. Of course, we did not develop all the parts ourselves—but we led the way. We developed most of the central components, forming the largest single contribution to the whole system. The basic vision was ours too.
In fairness, we ought to get at least equal mention.

See Linux and the GNU System and GNU Users Who Have Never Heard of GNU for more explanation, and The GNU Project for the history.

Why is the name important? (#whycare)
Although the developers of Linux, the kernel, are contributing to the free software community, many of them do not care about freedom. People who think the whole system is Linux tend to get confused and assign to those developers a role in the history of our community which they did not actually play. Then they give inordinate weight to those developers' views.
Calling the system GNU/Linux recognizes the role that our idealism played in building our community, and helps the public recognize the practical importance of these ideals.

What is the real relationship between GNU and Linux? (#what)
The GNU operating system and the Linux kernel are separate software projects that do complementary jobs. Typically they are packaged in a GNU/Linux distribution, and used together.
How did it come about that most people call the system “Linux”? (#howerror)
Calling the system “Linux” is a confusion that has spread faster than the corrective information.
The people who combined Linux with the GNU system were not aware that that's what their activity amounted to. They focused their attention on the piece that was Linux and did not realize that more of the combination was GNU. They started calling it “Linux” even though that name did not fit what they had. It took a few years for us to realize what a problem this was and ask people to correct the practice. By that time, the confusion had a big head start.

Most of the people who call the system “Linux” have never heard why that's not the right thing. They saw others using that name and assume it must be right. The name “Linux” also spreads a false picture of the system's origin, because people tend to suppose that the system's history was such as to fit that name. For instance, they often believe its development was started by Linus Torvalds in 1991. This false picture tends to reinforce the idea that the system should be called “Linux”.

Many of the questions in this file represent people's attempts to justify the name they are accustomed to using.

Should we always say “GNU/Linux” instead of “Linux”? (#always)
Not always—only when you're talking about the whole system. When you're referring specifically to the kernel, you should call it “Linux”, the name its developer chose.
When people call the whole system “Linux”, as a consequence they call the whole system by the same name as the kernel. This causes many kinds of confusion, because only experts can tell whether a statement is about the kernel or the whole system. By calling the whole system “GNU/Linux”, and calling the kernel “Linux”, you avoid the ambiguity.

Would Linux have achieved the same success if there had been no GNU? (#linuxalone)
In that alternative world, there would be nothing today like the GNU/Linux system, and probably no free operating system at all. No one attempted to develop a free operating system in the 1980s except the GNU Project and (later) Berkeley CSRG, which had been specifically asked by the GNU Project to start freeing its code.
Linus Torvalds was partly influenced by a speech about GNU in Finland in 1990. It's possible that even without this influence he might have written a Unix-like kernel, but it probably would not have been free software. Linux became free in 1992 when Linus rereleased it under the GNU GPL. (See the release notes for version 0.12.)

Even if Torvalds had released Linux under some other free software license, a free kernel alone would not have made much difference to the world. The significance of Linux came from fitting into a larger framework, a complete free operating system: GNU/Linux.

Wouldn't it be better for the community if you did not divide people with this request? (#divide)
When we ask people to say “GNU/Linux”, we are not dividing people. We are asking them to give the GNU Project credit for the GNU operating system. This does not criticize anyone or push anyone away.
However, there are people who do not like our saying this. Sometimes those people push us away in response. On occasion they are so rude that one wonders if they are intentionally trying to intimidate us into silence. It doesn't silence us, but it does tend to divide the community, so we hope you can convince them to stop.

However, this is only a secondary cause of division in our community. The largest division in the community is between people who appreciate free software as a social and ethical issue and consider proprietary software a social problem (supporters of the free software movement), and those who cite only practical benefits and present free software only as an efficient development model (the open source movement).

This disagreement is not just a matter of names—it is a matter of differing basic values. It is essential for the community to see and think about this disagreement. The names “free software” and “open source” are the banners of the two positions. See Why Open Source misses the point of Free Software.

The disagreement over values partially aligns with the amount of attention people pay to the GNU Project's role in our community. People who value freedom are more likely to call the system “GNU/Linux”, and people who learn that the system is “GNU/Linux” are more likely to pay attention to our philosophical arguments for freedom and community (which is why the choice of name for the system makes a real difference for society). However, the disagreement would probably exist even if everyone knew the system's real origin and its proper name, because the issue is a real one. It can only go away if we who value freedom either persuade everyone (which won't be easy) or are defeated entirely (let's hope not).

Doesn't the GNU project support an individual's free speech rights to call the system by any name that individual chooses? (#freespeech)
Yes, indeed, we believe you have a free speech right to call the operating system by any name you wish. We ask that people call it GNU/Linux as a matter of doing justice to the GNU project, to promote the values of freedom that GNU stands for, and to inform others that those values of freedom brought the system into existence.
Since everyone knows the role of GNU in developing the system, doesn't the “GNU/” in the name go without saying? (#everyoneknows)
Experience shows that the system's users, and the computer-using public in general, often know nothing about the GNU system. Most articles about the system do not mention the name “GNU”, or the ideals that GNU stands for. GNU Users Who Have Never Heard of GNU explains further.
The people who say this are probably geeks thinking of the geeks they know. Geeks often do know about GNU, but many have a completely wrong idea of what GNU is. For instance, many think it is a collection of “tools”, or a project to develop tools.

The wording of this question, which is typical, illustrates another common misconception. To speak of “GNU's role” in developing something assumes that GNU is a group of people. GNU is an operating system. It would make sense to talk about the GNU Project's role in this or some other activity, but not that of GNU.

Since I know the role of GNU in this system, why does it matter what name I use? (#everyoneknows2)
If your words don't reflect your knowledge, you don't teach others. Most people who have heard of the GNU/Linux system think it is “Linux”, that it was started by Linus Torvalds, and that it was intended to be “open source”. If you don't tell them, who will?
Isn't shortening “GNU/Linux” to “Linux” just like shortening “Microsoft Windows” to “Windows”? (#windows)
It's useful to shorten a frequently-used name, but not if the abbreviation is misleading.
Almost everyone in developed countries really does know that the “Windows” system is made by Microsoft, so shortening “Microsoft Windows” to “Windows” does not mislead anyone as to that system's nature and origin. Shortening “GNU/Linux” to “Linux” does give the wrong idea of where the system comes from.

The question is itself misleading because GNU and Microsoft are not the same kind of thing. Microsoft is a company; GNU is an operating system.

Isn't GNU a collection of programming tools that were included in Linux? (#tools)
People who think that Linux is an entire operating system, if they hear about GNU at all, often get a wrong idea of what GNU is. They may think that GNU is the name of a collection of programs—often they say “programming tools”, since some of our programming tools became popular on their own. The idea that “GNU” is the name of an operating system is hard to fit into a conceptual framework in which that operating system is labeled “Linux”.
The GNU Project was named after the GNU operating system—it's the project to develop the GNU system. (See the 1983 initial announcement.)

We developed programs such as GCC, GNU Emacs, GAS, GLIBC, BASH, etc., because we needed them for the GNU operating system. GCC, the GNU Compiler Collection is the compiler that we wrote for the GNU operating system. We, the many people working on the GNU Project, developed Ghostscript, GNUCash, GNU Chess and GNOME for the GNU system too.

What is the difference between an operating system and a kernel? (#osvskernel)
An operating system, as we use the term, means a collection of programs that are sufficient to use the computer to do a wide variety of jobs. A general purpose operating system, to be complete, ought to handle all the jobs that many users may want to do.
The kernel is one of the programs in an operating system—the program that allocates the machine's resources to the other programs that are running. The kernel also takes care of starting and stopping other programs.

To confuse matters, some people use the term “operating system” to mean “kernel”. Both uses of the term go back many years. The use of “operating system” to mean “kernel” is found in a number of textbooks on system design, going back to the 80s. At the same time, in the 80s, the “Unix operating system” was understood to include all the system programs, and Berkeley's version of Unix included even games. Since we intended GNU to be a Unix-like operating system, we use the term “operating system” in the same way.

Most of the time when people speak of the “Linux operating system” they are using “operating system” in the same sense we use: they mean the whole collection of programs. If that's what you are referring to, please call it “GNU/Linux”. If you mean just the kernel, then “Linux” is the right name for it, but please say “kernel” also to avoid ambiguity about which body of software you mean.

If you prefer to use some other term such as “system distribution” for the entire collection of programs, instead of “operating system”, that's fine. Then you would talk about GNU/Linux system distributions.

The kernel of a system is like the foundation of a house. How can a house be almost complete when it doesn't have a foundation? (#house)
A kernel is not much like the foundation of a house because building an operating system is not much like building a house.
A house is built from lots of little general parts that are cut and put together in situ. They have to be put together from the bottom up. Thus, when the foundation has not been built, no substantial part has been built; all you have is a hole in the ground.

By contrast, an operating system consists of complex components that can be developed in any order. When you have developed most of the components, most of the work is done. This is much more like the International Space Station than like a house. If most of the Space Station modules were in orbit but awaiting one other essential module, that would be like the GNU system in 1992.

Isn't the kernel the brain of the system? (#brain)
A computer system is not much like a human body, and no part of it plays a role comparable to that of the brain in a human.
Isn't writing the kernel most of the work in an operating system? (#kernelmost)
No, many components take a lot of work.
How can GNU be an operating system, if I can't get something called “GNU” and install it? (#notinstallable)
Many packaged and installable versions of GNU are available. None of them is called simply “GNU”, but GNU is what they basically are.
We expected to release the GNU system packaged for installation, but this plan was overtaken by events: in 1992 others were already packaging GNU variants containing Linux. Starting in 1993 we sponsored an effort to make a better and freer GNU/Linux distribution, called Debian GNU/Linux. The founder of Debian had already chosen that name. We did not ask him to call it just “GNU” because that was to be the name of a system version with the GNU Hurd kernel—which wasn't ready yet.

The GNU Hurd kernel never became sufficiently ready; we only recommend it to those interested in working on it. So we never packaged GNU with the GNU Hurd kernel. However, Debian packaged this combination as Debian GNU/Hurd.

We are now developing an advanced Scheme-based package manager called Guix and a complete system distribution based on it called the Guix System Distribution or GuixSD. This includes repackaging a substantial part of the GNU system.

We never took the last step of packaging GNU under the name “GNU”, but that doesn't alter what kind of thing GNU is. GNU is an operating system.

We're calling the whole system after the kernel, Linux. Isn't it normal to name an operating system after a kernel? (#afterkernel)
That practice seems to be very rare—we can't find any examples other than the misuse of the name “Linux”. Normally an operating system is developed as a single unified project, and the developers choose a name for the system as a whole. The kernel usually does not have a name of its own—instead, people say “the kernel of such-and-such” or “the such-and-such kernel”.
Because those two constructions are used synonymously, the expression “the Linux kernel” can easily be misunderstood as meaning “the kernel of Linux” and implying that Linux must be more than a kernel. You can avoid the possibility of this misunderstanding by saying or writing “the kernel, Linux” or “Linux, the kernel.”

Can another system have “the feel of Linux”? (#feel)
There is no such thing as the “feel of Linux” because Linux has no user interfaces. Like any modern kernel, Linux is a base for running programs; user interfaces belong elsewhere in the system. Human interaction with GNU/Linux always goes through other programs, and the “feel” comes from them.
The problem with “GNU/Linux” is that it is too long. How about recommending a shorter name? (#long)
For a while we tried the name “LiGNUx”, which combines the words “GNU” and “Linux”. The reaction was very bad. People accept “GNU/Linux” much better.
The shortest legitimate name for this system is “GNU”, but we call it “GNU/Linux” for the reasons given below.

How about calling the system “GliNUx” (instead of “GNU/Linux”)? (#long1)
The name “GNU” does not visibly appear in “Glinux,” so most people would not notice it is there. Even if it is capitalized as “GliNUx,” most people would not realize that it contains a reference to GNU.

It would be comparable to writing “GNU/Linux,” but putting “GNU/” in print so small that most people could not read it.

The problem with “GNU/Linux” is that it is too long. Why should I go to the trouble of saying “GNU/”? (#long2)
It only takes a second to say or type “GNU/”. If you appreciate the system that we developed, can't you take one second to recognize our work?

Unfortunately, “GNU/Linux” is five syllables. People won't use such a long term. Shouldn't you find a shorter one? (#long3)
Actually, “GNU/Linux” is only four syllables. “Unfortunately” is five syllables, yet people show no sign of reluctance to use that word.

Since Linux is a secondary contribution, would it be false to the facts to call the system simply “GNU”? (#justgnu)
It would not be false to the facts, but it is not the best thing to do. Here are the reasons we call that system version “GNU/Linux” rather than just “GNU”:
It's not exactly GNU—it has a different kernel (that is, Linux). Distinguishing GNU/Linux from GNU is useful.
It would be ungentlemanly to ask people to stop giving any credit to Linus Torvalds. He did write an important component of the system. We want to get credit for launching and sustaining the system's development, but this doesn't mean we should treat Linus the same way those who call the system “Linux” treat us. We strongly disagree with his political views, but we deal with that disagreement honorably and openly, rather than by trying to cut him out of the credit for his contribution to the system.
Since many people know of the system as “Linux”, if we say “GNU” they may simply not recognize we're talking about the same system. If we say “GNU/Linux”, they can make a connection to what they have heard about.
I would have to pay a fee if I use “Linux” in the name of a product, and that would also apply if I say “GNU/Linux”. Is it wrong if I use “GNU” without “Linux”, to save the fee? (#trademarkfee)
There's nothing wrong in calling the system “GNU”; basically, that's what it is. It is nice to give Linus Torvalds a share of the credit as well, but you have no obligation to pay for the privilege of doing so.
So if you want to refer to the system simply as “GNU”, to avoid paying the fee for calling it “Linux”, we won't criticize you.

Many other projects contributed to the system as it is today; it includes TeX, X11, Apache, Perl, and many more programs. Don't your arguments imply we have to give them credit too? (But that would lead to a name so long it is absurd.) (#many)
What we say is that you ought to give the system's principal developer a share of the credit. The principal developer is the GNU Project, and the system is basically GNU.
If you feel even more strongly about giving credit where it is due, you might feel that some secondary contributors also deserve credit in the system's name. If so, far be it from us to argue against it. If you feel that X11 deserves credit in the system's name, and you want to call the system GNU/X11/Linux, please do. If you feel that Perl simply cries out for mention, and you want to write GNU/Linux/Perl, go ahead.

Since a long name such as GNU/X11/Apache/Linux/TeX/Perl/Python/FreeCiv becomes absurd, at some point you will have to set a threshold and omit the names of the many other secondary contributions. There is no one obvious right place to set the threshold, so wherever you set it, we won't argue against it.

Different threshold levels would lead to different choices of name for the system. But one name that cannot result from concerns of fairness and giving credit, not for any possible threshold level, is “Linux”. It can't be fair to give all the credit to one secondary contribution (Linux) while omitting the principal contribution (GNU).

Many other projects contributed to the system as it is today, but they don't insist on calling it XYZ/Linux. Why should we treat GNU specially? (#others)
Thousands of projects have developed programs commonly included in today's GNU/Linux systems. They all deserve credit for their contributions, but they aren't the principal developers of the system as a whole, so they don't ask to be credited as such.
GNU is different because it is more than just a contributed program, more than just a collection of contributed programs. GNU is the framework on which the system was made.

GNU is a small fraction of the system nowadays, so why should we mention it? (#allsmall)
In 2008, we found that GNU packages made up 15% of the “main” repository of the gNewSense GNU/Linux distribution. Linux made up 1.5%. So the same argument would apply even more strongly to calling it “Linux”.
GNU is a small fraction of the system nowadays, and Linux is an even smaller fraction. But they are the system's core; the system was made by combining them. Thus, the name “GNU/Linux” remains appropriate.

Many companies contributed to the system as it is today; doesn't that mean we ought to call it GNU/Red Hat/Novell/Linux? (#manycompanies)
GNU is not comparable to Red Hat or Novell; it is not a company, or an organization, or even an activity. GNU is an operating system. (When we speak of the GNU Project, that refers to the project to develop the GNU system.) The GNU/Linux system is based on GNU, and that's why GNU ought to appear in its name.

Much of those companies' contribution to the GNU/Linux system lies in the code they have contributed to various GNU packages including GCC and GNOME. Saying GNU/Linux gives credit to those companies along with all the rest of the GNU developers.

Why do you write “GNU/Linux” instead of “GNU Linux”? (#whyslash)
Following the rules of English, in the construction “GNU Linux” the word “GNU” modifies “Linux”. This can mean either “GNU's version of Linux” or “Linux, which is a GNU package.” Neither of those meanings fits the situation at hand.
Linux is not a GNU package; that is, it wasn't developed under the GNU Project's aegis or contributed specifically to the GNU Project. Linus Torvalds wrote Linux independently, as his own project. So the “Linux, which is a GNU package” meaning is not right.

We're not talking about a distinct GNU version of Linux, the kernel. The free GNU/Linux distros do have a separate version of Linux, since the “standard” version contains non-free firmware “blobs”. If this were part of the GNU Project, it could be considered “GNU Linux”; but we would not want to call it that, because it would be too confusing.

We're talking about a version of GNU, the operating system, distinguished by having Linux as the kernel. A slash fits the situation because it means “combination.” (Think of “Input/Output”.) This system is the combination of GNU and Linux; hence, “GNU/Linux”.

There are other ways to express “combination”. If you think that a plus-sign is clearer, please use that. In French, a hyphen is clear: “GNU-Linux”. In Spanish, we sometimes say “GNU con Linux”.

Why “GNU/Linux” rather than “Linux/GNU”? (#whyorder)
It is right and proper to mention the principal contribution first. The GNU contribution to the system is not only bigger than Linux and prior to Linux, we actually started the whole activity.

In addition, “GNU/Linux” fits the fact that Linux is the lowest level of the system and GNU fills technically higher levels.

However, if you prefer to call the system “Linux/GNU”, that is a lot better than what people usually do, which is to omit GNU entirely and make it seem that the whole system is Linux.

My distro's developers call it “Foobar Linux”, but that doesn't say anything about what the system consists of. Why shouldn't they call it whatever they like? (#distronames0)
Calling a system “Foobar Linux” implies that it's a flavor of “Linux,” and people understand it that way.
If they called a GNU/Linux distro “Foobar BSD,” you would call that a mistake. “This system is not BSD,” you would tell them. Well, it's not Linux either.

My distro is called “Foobar Linux”; doesn't that show it's really Linux? (#distronames)
It means that the people who make the “Foobar Linux” distro are repeating the common mistake. We appreciate that distributions like Debian, Dragora, Musix, Trisquel, and Venenux have adopted GNU/Linux as part of their official name, and we hope that if you are involved with a different distribution, you will encourage it to do the same.

My distro's official name is “Foobar Linux”; isn't it wrong to call the distro anything but “Foobar Linux”? (#distronames1)
When they spread misinformation by changing “GNU” to “Linux”, and call their version of it “Foobar Linux”, it's proper for you to correct the misinformation by calling it “Foobar GNU/Linux”.

Wouldn't it be more effective to ask companies such as Mandrake, Red Hat and IBM to call their distributions “GNU/Linux” rather than asking individuals? (#companies)
It isn't a choice of one or the other—we ask companies and organizations and individuals to help spread the word about this. In fact, we have asked all three of those companies. Mandrake said it would use the term “GNU/Linux” some of the time, but IBM and Red Hat were unwilling to help. One executive said, “This is a pure commercial decision; we expect to make more money calling it ‘Linux’.” In other words, that company did not care what was right.
We can't make them do this right, but we're not the sort to give up just because the road isn't easy. You may not have as much influence at your disposal as IBM or Red Hat, but you can still help. Together we can change the situation to the point where companies will make more profit calling it “GNU/Linux”.

Wouldn't it be better to reserve the name “GNU/Linux” for distributions that are purely free software? After all, that is the ideal of GNU. (#reserve)
The widespread practice of adding non-free software to the GNU/Linux system is a major problem for our community. It teaches the users that non-free software is ok, and that using it is part of the spirit of “Linux”. Many “Linux” User Groups make it part of their mission to help users use non-free add-ons, and may even invite salesmen to come and make sales pitches for them. They adopt goals such as “helping the users” of GNU/Linux (including helping them use non-free applications and drivers), or making the system more popular even at the cost of freedom.
The question is how to try to change this.

Given that most of the community which uses GNU with Linux already does not realize that's what it is, for us to disown these adulterated versions, saying they are not really GNU, would not teach the users to value freedom more. They would not get the intended message. They would only respond they never thought these systems were GNU in the first place.

The way to lead these users to see a connection with freedom is exactly the opposite: to inform them that all these system versions are versions of GNU, that they all are based on a system that exists specifically for the sake of the users' freedom. With this understanding, they can start to recognize the distributions that include non-free software as perverted, adulterated versions of GNU, instead of thinking they are proper and appropriate “versions of Linux”.

It is very useful to start GNU/Linux User Groups, which call the system GNU/Linux and adopt the ideals of the GNU Project as a basis for their activities. If the Linux User Group in your area has the problems described above, we suggest you either campaign within the group to change its orientation (and name) or start a new group. The people who focus on the more superficial goals have a right to their views, but don't let them drag you along!

Why not make a GNU distribution of Linux (sic) and call that GNU/Linux? (#gnudist)
All the “Linux” distributions are actually versions of the GNU system with Linux as the kernel. The purpose of the term “GNU/Linux” is to communicate this point. To develop one new distribution and call that alone “GNU/Linux” would obscure the point we want to make.
As for developing a distribution of GNU/Linux, we already did this once, when we funded the early development of Debian GNU/Linux. To do it again now does not seem useful; it would be a lot of work, and unless the new distribution had substantial practical advantages over other distributions, it would serve no purpose.

Instead we help the developers of 100% free GNU/Linux distributions, such as gNewSense and Ututo.

Why not just say “Linux is the GNU kernel” and release some existing version of GNU/Linux under the name “GNU”? (#linuxgnu)
It might have been a good idea to adopt Linux as the GNU kernel back in 1992. If we had realized, then, how long it would take to get the GNU Hurd to work, we might have done that. (Alas, that is hindsight.)
If we were to take an existing version of GNU/Linux and relabel it as “GNU”, that would be somewhat like making a version of the GNU system and labeling it “Linux”. That wasn't right, and we don't want to act like that.

Did the GNU Project condemn and oppose use of Linux in the early days? (#condemn)
We did not adopt Linux as our kernel, but we didn't condemn or oppose it. In 1993 we started discussing the arrangements to sponsor the development of Debian GNU/Linux. We also sought to cooperate with the people who were changing some GNU packages for use with Linux. We wanted to include their changes in the standard releases so that these GNU packages would work out-of-the-box in combination with Linux. But the changes were often ad-hoc and nonportable; they needed to be cleaned up for installation.
The people who had made the changes showed little interest in cooperating with us. One of them actually told us that he didn't care about working with the GNU Project because he was a “Linux user”. That came as a shock, because the people who ported GNU packages to other systems had generally wanted to work with us to get their changes installed. Yet these people, developing a system that was primarily based on GNU, were the first (and still practically the only) group that was unwilling to work with us.

It was this experience that first showed us that people were calling a version of the GNU system “Linux”, and that this confusion was obstructing our work. Asking you to call the system “GNU/Linux” is our response to that problem, and to the other problems caused by the “Linux” misnomer.

Why did you wait so long before asking people to use the name GNU/Linux? (#wait)
Actually we didn't. We began talking privately with developers and distributors about this in 1994, and made a more public campaign in 1996. We will continue for as long as it's necessary.

Should the GNU/name convention be applied to all programs that are GPL'ed? (#allgpled)
We never refer to individual programs as “GNU/name”. When a program is a GNU package, we may call it “GNU name”.
GNU, the operating system, is made up of many different programs. Some of the programs in GNU were written as part of the GNU Project or specifically contributed to it; these are the GNU packages, and we often use “GNU” in their names.

It's up to the developers of a program to decide if they want to contribute it and make it a GNU package. If you have developed a program and you would like it to be a GNU package, please write to <gnu@gnu.org>, so we can evaluate it and decide whether we want it.

It wouldn't be fair to put the name GNU on every individual program that is released under the GPL. If you write a program and release it under the GPL, that doesn't mean the GNU Project wrote it or that you wrote it for us. For instance, the kernel, Linux, is released under the GNU GPL, but Linus did not write it as part of the GNU Project—he did the work independently. If something is not a GNU package, the GNU Project can't take credit for it, and putting “GNU” in its name would be improper.

In contrast, we do deserve the overall credit for the GNU operating system as a whole, even though not for each and every program in it. The system exists as a system because of our determination and persistence, starting in 1984, many years before Linux was begun.

The operating system in which Linux became popular was basically the same as the GNU operating system. It was not entirely the same, because it had a different kernel, but it was mostly the same system. It was a variant of GNU. It was the GNU/Linux system.

Linux continues to be used primarily in derivatives of that system—in today's versions of the GNU/Linux system. What gives these systems their identity is GNU and Linux at the center of them, not particularly Linux alone.

Since much of GNU comes from Unix, shouldn't GNU give credit to Unix by using “Unix” in its name? (#unix)
Actually, none of GNU comes from Unix. Unix was proprietary software (and still is), so using any of its code in GNU would have been illegal. This is not a coincidence; this is why we developed GNU: since you could not have freedom in using Unix, or any of the other operating systems of the day, we needed a free system to replace it. We could not copy programs, or even parts of them, from Unix; everything had to be written afresh.
No code in GNU comes from Unix, but GNU is a Unix-compatible system; therefore, many of the ideas and specifications of GNU do come from Unix. The name “GNU”, which stands for “GNU's Not Unix”, is a humorous way of giving credit to Unix for this, following a hacker tradition of recursive acronyms that started in the 70s.

The first such recursive acronym was TINT, “TINT Is Not TECO”. The author of TINT wrote another implementation of TECO (there were already many of them, for various systems), but instead of calling it by a dull name like “somethingorother TECO”, he thought of a clever amusing name. (That's what hacking means: playful cleverness.)

Other hackers enjoyed that name so much that we imitated the approach. It became a tradition that, when you were writing from scratch a program that was similar to some existing program (let's imagine its name was “Klever”), you could give it a recursive acronym name, such as “MINK” for “MINK Is Not Klever.” In this same spirit we called our replacement for Unix “GNU's Not Unix”.

Historically, AT&T which developed Unix did not want anyone to give it credit by using “Unix” in the name of a similar system, not even in a system 99% copied from Unix. AT&T actually threatened to sue anyone giving AT&T credit in that way. This is why each of the various modified versions of Unix (all proprietary, like Unix) had a completely different name that didn't include “Unix”.

Should we say “GNU/BSD” too? (#bsd)
We don't call the BSD systems (FreeBSD, etc.) “GNU/BSD” systems, because that term does not fit the history of the BSD systems.
The BSD system was developed by UC Berkeley as non-free software in the 80s, and became free in the early 90s. A free operating system that exists today is almost certainly either a variant of the GNU system, or a kind of BSD system.

People sometimes ask whether BSD too is a variant of GNU, as GNU/Linux is. It is not. The BSD developers were inspired to make their code free software by the example of the GNU Project, and explicit appeals from GNU activists helped convince them to start, but the code had little overlap with GNU.

BSD systems today use some GNU packages, just as the GNU system and its variants use some BSD programs; however, taken as wholes, they are two different systems that evolved separately. The BSD developers did not write a kernel and add it to the GNU system, so a name like GNU/BSD would not fit the situation.

The connection between GNU/Linux and GNU is much closer, and that's why the name “GNU/Linux” is appropriate for it.

There is a version of GNU which uses the kernel from NetBSD. Its developers call it “Debian GNU/NetBSD”, but “GNU/kernelofNetBSD” would be more accurate, since NetBSD is an entire system, not just the kernel. This is not a BSD system, since most of the system is the same as the GNU/Linux system.

If I install the GNU tools on Windows, does that mean I am running a GNU/Windows system? (#othersys)
Not in the same sense that we mean by “GNU/Linux”. The tools of GNU are just a part of the GNU software, which is just a part of the GNU system, and underneath them you would still have another complete operating system which has no code in common with GNU. All in all, that's a very different situation from GNU/Linux.
Can't Linux be used without GNU? (#justlinux)
Linux is used by itself, or with small other programs, in some appliances. These small software systems are a far cry from the GNU/Linux system. Users do not install them on PCs, for instance, and would find them rather disappointing. It is useful to say that these appliances run just Linux, to show how different those small platforms are from GNU/Linux.
How much of the GNU system is needed for the system to be GNU/Linux? (#howmuch)
“How much” is not a meaningful question because the GNU system does not have precise boundaries.
GNU is an operating system maintained by a community. It includes far more than just the GNU software packages (of which we have a specific list), and people add more packages constantly. Despite these changes, it remains the GNU system, and adding Linux to that yields GNU/Linux. If you use part of the GNU system and omit part, there is no meaningful way to say “how much” you used.

If we look at the level of packages, Linux is one important package in the GNU/Linux system. The inclusion of one important GNU package is enough to justify our request for equal mention.

Are there complete Linux systems [sic] without GNU? (#linuxsyswithoutgnu)
There are complete systems that contain Linux and not GNU; Android is an example. But it is a mistake to call them “Linux” systems, just as it is a mistake to call GNU a “Linux” system.
Android is very different from the GNU/Linux system—because the two have very little code in common. In fact, the only thing they have in common is Linux.

If you call the whole GNU/Linux system “Linux”, you will find it necessary to say things like, “Android contains Linux, but it isn't Linux, because it doesn't have the usual Linux [sic] libraries and utilities [meaning the GNU system].”

Android contains just as much of Linux as GNU/Linux does. What it doesn't have is the GNU system. Android replaces that with Google software that works quite differently. What makes Android different from GNU/Linux is the absence of GNU.

Is it correct to say “using Linux” if it refers to using GNU/Linux and using Android? (#usegnulinuxandandroidlinuxsyswithoutgnu)
Far from it. That usage is so strained that people will not understand the intended meaning.
The public will find it very strange to speak of using Android as “using Linux”. It's like having a conversation, then saying you were conversing with the person's intestines or the person's circulatory system.

The public will understand the idea of “using Linux” when it's really GNU/Linux, by way of the usual misunderstanding: thinking of the whole system as “Linux”.

Use of Android and use of GNU/Linux are totally different, as different as driving a car and riding a bicycle. The fact that the first two both contain Linux is irrelevant to using them, just as the fact that a car and a bicycle both have a structure of metal is irrelevant to using those two. If you wish to talk about using cars and bikes, you wouldn't speak of “riding metal objects” — not unless you're playing games with the reader. You would say, “using cars and bikes.” Likewise, the clear way to talk about using GNU/Linux and Android is to say “using GNU/Linux and Android.”

Why not call the system “Linux” anyway, and strengthen Linus Torvalds' role as posterboy for our community? (#helplinus)
Linus Torvalds is the “posterboy” (other people's choice of word, not ours) for his goals, not ours. His goal is to make the system more popular, and he believes its value to society lies merely in the practical advantages it offers: its power, reliability and easy availability. He has never advocated freedom to cooperate as an ethical principle, which is why the public does not connect the name “Linux” with that principle.
Linus publicly states his disagreement with the free software movement's ideals. He developed non-free software in his job for many years (and said so to a large audience at a “Linux”World show), and publicly invited fellow developers of Linux, the kernel, to use non-free software to work on it with him. He goes even further, and rebukes people who suggest that engineers and scientists should consider social consequences of our technical work—rejecting the lessons society learned from the development of the atom bomb.

There is nothing wrong with writing a free program for the motivations of learning and having fun; the kernel Linus wrote for those reasons was an important contribution to our community. But those motivations are not the reason why the complete free system, GNU/Linux, exists, and they won't secure our freedom in the future. The public needs to know this. Linus has the right to promote his views; however, people should be aware that the operating system in question stems from ideals of freedom, not from his views.

Isn't it wrong for us to label Linus Torvalds' work as GNU? (#claimlinux)
It would be wrong, so we don't do that. Torvalds' work is Linux, the kernel; we are careful not to attribute that work to the GNU Project or label it as “GNU”. When we talk about the whole system, the name “GNU/Linux” gives him a share of the credit.
Does Linus Torvalds agree that Linux is just the kernel? (#linusagreed)
He recognized this at the beginning. The earliest Linux release notes said, “Most of the tools used with linux are GNU software and are under the GNU copyleft. These tools aren't in the distribution - ask me (or GNU) for more info”.

Why not finish the GNU Hurd kernel, release the GNU system as a whole, and forget the question of what to call GNU/Linux? (#finishhurd)
We would like credit for the GNU operating system no matter which kernel is used with it.
Making the GNU Hurd work well enough to compete with Linux would be a big job, and it's not clearly necessary. The only thing ethically wrong with Linux as a kernel is its inclusion of firmware “blobs”; the best fix for that problem is developing free replacement for the blobs.

The battle is already lost—society has made its decision and we can't change it, so why even think about it? (#lost)
This isn't a battle, it is a campaign of education. What to call the system is not a single decision, to be made at one moment by “society”: each person, each organization, can decide what name to use. You can't make others say “GNU/Linux”, but you can decide to call the system “GNU/Linux” yourself—and by doing so, you will help educate others.
Society has made its decision and we can't change it, so what good does it do if I say “GNU/Linux”? (#whatgood)
This is not an all-or-nothing situation: correct and incorrect pictures are being spread more or less by various people. If you call the system “GNU/Linux”, you will help others learn the system's true history, origin, and reason for being. You can't correct the misnomer everywhere on your own, any more than we can, but you can help. If only a few hundred people see you use the term “GNU/Linux”, you will have educated a substantial number of people with very little work. And some of them will spread the correction to others.
Wouldn't it be better to call the system “Linux” and teach people its real origin with a ten-minute explanation? (#explain)
If you help us by explaining to others in that way, we appreciate your effort, but that is not the best method. It is not as effective as calling the system “GNU/Linux”, and uses your time inefficiently.
It is ineffective because it may not sink in, and surely will not propagate. Some of the people who hear your explanation will pay attention, and they may learn a correct picture of the system's origin. But they are unlikely to repeat the explanation to others whenever they talk about the system. They will probably just call it “Linux”. Without particularly intending to, they will help spread the incorrect picture.

It is inefficient because it takes a lot more time. Saying and writing “GNU/Linux” will take you only a few seconds a day, not minutes, so you can afford to reach far more people that way. Distinguishing between Linux and GNU/Linux when you write and speak is by far the easiest way to help the GNU Project effectively.

Some people laugh at you when you ask them to call the system GNU/Linux. Why do you subject yourself to this treatment? (#treatment)
Calling the system “Linux” tends to give people a mistaken picture of the system's history and reason for existence. People who laugh at our request probably have picked up that mistaken picture—they think our work was done by Linus, so they laugh when we ask for credit for it. If they knew the truth, they probably wouldn't laugh.
Why do we take the risk of making a request that sometimes leads people to ridicule us? Because often it has useful results that help the GNU Project. We will run the risk of undeserved abuse to achieve our goals.

If you see such an ironically unfair situation occurring, please don't sit idly by. Please teach the laughing people the real history. When they see why the request is justified, those who have any sense will stop laughing.

Some people condemn you when you ask them to call the system GNU/Linux. Don't you lose by alienating them? (#alienate)
Not much. People who don't appreciate our role in developing the system are unlikely to make substantial efforts to help us. If they do work that advances our goals, such as releasing free software, it is probably for other unrelated reasons, not because we asked them. Meanwhile, by teaching others to attribute our work to someone else, they are undermining our ability to recruit the help of others.
It makes no sense to worry about alienating people who are already mostly uncooperative, and it is self-defeating to be deterred from correcting a major problem lest we anger the people who perpetuate it. Therefore, we will continue trying to correct the misnomer.

Whatever you contributed, is it legitimate to rename the operating system? (#rename)
We are not renaming anything; we have been calling this system “GNU” ever since we announced it in 1983. The people who tried to rename it to “Linux” should not have done so.
Isn't it wrong to force people to call the system “GNU/Linux”? (#force)
It would be wrong to force them, and we don't try. We call the system “GNU/Linux”, and we ask you to do it too.
Why not sue people who call the whole system “Linux”? (#whynotsue)
There are no legal grounds to sue them, but since we believe in freedom of speech, we wouldn't want to do that anyway. We ask people to call the system “GNU/Linux” because that is the right thing to do.
Shouldn't you put something in the GNU GPL to require people to call the system “GNU”? (#require)
The purpose of the GNU GPL is to protect the users' freedom from those who would make proprietary versions of free software. While it is true that those who call the system “Linux” often do things that limit the users' freedom, such as bundling non-free software with the GNU/Linux system or even developing non-free software for such use, the mere act of calling the system “Linux” does not, in itself, deny users their freedom. It seems improper to make the GPL restrict what name people can use for the system.
Since you objected to the original BSD license's advertising requirement to give credit to the University of California, isn't it hypocritical to demand credit for the GNU project? (#BSDlicense)
It would be hypocritical to make the name GNU/Linux a license requirement, and we don't. We only ask you to give us the credit we deserve.
Please note that there are at least two different BSD licenses. For clarity's sake, please don't use the term “BSD license” without specifying which one.

Since you failed to put something in the GNU GPL to require people to call the system “GNU”, you deserve what happened; why are you complaining now? (#deserve)
The question presupposes a rather controversial general ethical premise: that if people do not force you to treat them fairly, you are entitled to take advantage of them as much as you like. In other words, it assumes that might makes right.
We hope you disagree with that premise just as we do.

Wouldn't you be better off not contradicting what so many people believe? (#contradict)
We don't think we should go along with large numbers of people because they have been misled. We hope you too will decide that truth is important.
We could never have developed a free operating system without first denying the belief, held by most people, that proprietary software was legitimate and acceptable.

Since many people call it “Linux”, doesn't that make it right? (#somanyright)
We don't think that the popularity of an error makes it the truth.
Isn't it better to call the system by the name most users already know? (#knownname)
Users are not incapable of learning. Since “GNU/Linux” includes “Linux”, they will recognize what you're talking about. If you add “(often erroneously referred to as ‘Linux’)” once in a while, they will all understand.
Many people care about what's convenient or who's winning, not about arguments of right or wrong. Couldn't you get more of their support by a different road? (#winning)
To care only about what's convenient or who's winning is an amoral approach to life. Non-free software is an example of that amoral approach and thrives on it. Thus, in the long run it would be self-defeating for us to adopt that approach. We will continue talking in terms of right and wrong.
We hope that you are one of those for whom right and wrong do matter.


https://www.gnu.org/education/education.html
Free Software and Education
How Does Free Software Relate to Education?
Software freedom plays a fundamental role in education. Educational institutions of all levels should use and teach Free Software because it is the only software that allows them to accomplish their essential missions: to disseminate human knowledge and to prepare students to be good members of their community. The source code and the methods of Free Software are part of human knowledge. On the contrary, proprietary software is secret, restricted knowledge, which is the opposite of the mission of educational institutions. Free Software supports education, proprietary software forbids education.

Free Software is not just a technical question; it is an ethical, social, and political question. It is a question of the human rights that the users of software ought to have. Freedom and cooperation are essential values of Free Software. The GNU System implements these values and the principle of sharing, since sharing is good and beneficial to human progress.

To learn more, see the Free Software definition and our article on why software should be free (as in freedom).

The Basics
The GNU Project was launched in 1983 by Richard Stallman to develop a Free Libre operating system: the GNU operating system. As a result, today it is possible for anyone to use a computer in freedom.

In this six-minutes video Richard Stallman explains briefly and to the point the principles of Free Software and how they connect to education.


https://www.gnu.org/education/edu-software-gcompris.html
GCompris
Description
Screenshot of the GCompris interface showing the various activities.
GCompris is a cross-platform complete educational suite for children from 2 to 10 years old, and it is part of the GNU project. It includes more than 140 entertaining activities that help little kids learn skills such as the recognition of letters and numbers, the use of the mouse and keyboard, basic algebra training, reading time on an analog clock, vector drawing, language learning through games, and much more. The program includes a simple text processor to produce documents with basic text style. Another feature is the animation tool, which can be employed as a simple and effective method to support story telling, thus improving communication with children and helping them to express themselves.

GCompris includes several activities grouped on a yellow bar to the left of the screen, from which the child can choose as soon as the program is started. Such a design makes it easy to add new activities or to adapt the program to specific needs. The program itself and all the activities are available in many different languages.

To learn more: FSF Directory, GCompris Official Website

Who's Using It and How
Gcompris activity-based design makes it highly and easily adaptable to particular environments. One example of innovative use of the program is in the work done by the Insight Project of Kerala, in India. The project aims to bring the benefits of Free Software to differently abled people in the State. They found that GCompris is a powerful tool to improve the communicative and motor skills of mentally challenged persons like children with autism. The project is using and adapting the program for the particular needs of its target community.

The Insight team implemented a training module for teachers that provides instructions on how to use the different activities of GCompris when working with children with special needs, to help these children acquire abilities such as eye-hand coordination, memory, listening, and improving the child's attention span. The module addresses different levels of education, from pre-school to the primary level. A small handbook was also distributed to parents and special educators to help them understand how to use the software to improve children's skills.

GCompris is also used to help older children understand the relationship between numbers, learn basic arithmetic operations, train them in analytical reasoning, and to improve communicative skills as well as spelling, reading and writing.

Why
Teachers report that it is extremely easy for them to implement GCompris in their curriculum since children find it intuitive and fun to use. The program is also an excellent resource for mentally challenged children and adults.

GCompris has become an important resource to speed up the child's learning process in the context of developing countries like India, where the only chance for a child of getting accustomed with computers is during school time. At school, the computers are often shared and children have limited time to access them individually. GCompris is easy to use and intuitive, so it is particularly useful in this environment because there is practically no time spent on getting to understand how the program works. With GCompris children develop quickly the motor skills required to use a computer.

Results
GCompris respects the users' fundamental freedoms and this permitted the Insight developers and specialists to adapt the software to the children's needs, creating new activities, and proposing the innovative use of the program to help autistic children and their parents. The Insight team is also free to distribute copies of the modified version to teachers and parents, who can use the program at home without restrictions. The modified version has proved effective in improving the academic and functional flair of intellectually challenged children.


https://www.gnu.org/education/edu-software-gimp.html
GIMP
Description
GIMP stands for “GNU Image Manipulation Program”, a self-explanatory name for an application that processes digital graphics and is part of the GNU Project, meaning that it follows the GNU standards and is released under the GNU General Public License, version 3 or later, to ensure maximum protection of users' freedom. It can be used both as a simple tool for basic painting and drawing and as a powerful program for complex tasks such as advanced photo retouching, digital image composition, editing and animation, as well as authoring of original art. Apart from the usual features included in similar programs, GIMP displays an array of highly sophisticated options aimed at computer graphics professionals. It is also multi-platform, and it handles a wide range of formats plus format conversion.

To learn more: FSF Directory, GIMP Official Website

Who's Using It and How
The GIMP is used by a large number of artists, amateurs, Web developers, educators. At school it is a handy tool that assists students and teachers in the preparation of graphic materials for slides, handouts, the school's Web site or bulletin and similar projects.

French artist Isabel Saij describes how she uses GIMP for her work:

“It's a program I use for different works: photo manipulation (mixing images together), drawings (my 'digital fragments' in relation to my 'real fragments' made on paper), teaching to teenagers, preparing images for video, etc.). In other words, one of my favorite programs.”

There are many interesting examples of how this program is put to use by professionals and amateurs alike to effectively bring to life their ideas without giving up their freedom as computer users. Among those, there is one that goes beyond the ordinary.

How GIMP changed Mani's life.
Mani began his journey towards liberation from social constraints as an enthusiastic and talented teenager. His awareness and commitment to freedom led him to actively participate in the formation of a grassroots volunteer group in 2007, with the goal of introducing computer knowledge in his slum area in Bangalore through the use of freedom-respecting software. This brought sustained improvement to his community and ultimately a radical turn in his own life.

The group set up a Free Software computer lab in the slum dwelling and Mani learned fast, becoming a teacher himself to help his peers develop better skills in the use of the various applications. He soon acquired a mastery of the advanced techniques of GIMP, and, combining technical knowledge with innate artistic abilities, he produced graphical art that he exhibited and sold. The following three-minutes video portrays Mani's endeavor to learn Free Software.

Watch and download the video as Ogg Theora at a higher resolution.

Note to the hearing-impaired: the only audio in this video is the soundtrack, which is a piano version of the Free Software Song.

Note to the visually impaired: A written description of the video is available.

At the time of writing (March 2012) Mani is a student of Computer Science in Bangalore. He says:

“First I need to say thanks to the Free Software movement, it allowed me to start learning GIMP. It was my first achievement in life, and I sold many paintings at a Free Software conference. Later I started displaying my works in many conferences. Because of GIMP, my painting skills are brought out to the world. As you know, our talents are usually ignored by the world. Our aims in the community are: to share software and knowledge, to learn from each other; to promote the Free Software ethical values and raise awareness about the importance of software freedom in a marginalized social environment; to empower the poor with computer knowledge. We want to replicate our model, we are already running three computer centers in other slums in the area.”

Richard Stallman's comment on this case:

“I am more proud that GNU has been adopted by Indian Dalits than of its use by famous corporations.”

Why
The interests of nonfree software developers are at odds with the needs of users from all segments of society, given that they deny basic human values such as collaboration and sharing. Proprietary software companies deem irrelevant to their profit goals the damage that their policies cause to users of their products.

In complex social structures such as that of India, exclusion of the underprivileged from access to information technologies is just one of the multiple instances of discrimination this sector of society faces at many levels: healthcare, housing, education, employment, to name a few. Over time, these vulnerable groups have attained a high degree of awareness about the importance of mutual collaboration, a basic human value often forgotten or even dismissed among the educated and affluent spheres of society in all cultures. The principles of sharing and reciprocal concern are deeply rooted in these communities and constitute valuable assets in their struggle for survival. The social bond among its members is solid and strong, a bulwark against the incursion of additional sources of exclusion.

In that scenario, the introduction of proprietary software would not be accepted by these socially committed people since that would result in the imposition of further restrictions on them as computer users. They would not refrain from installing the software in as many computers as needed or use it as they please, they would not give up their right to access knowledge by studying how computer programs work, they would not sign away their right to modify or distribute the programs and, above all, they would not give up their right to share copies with their neighbors. All of these freedoms are granted to them only by Free Software.

The restrictions imposed on users by proprietary software developers serve to attack other layers of society as well, specially the upper spending classes, since those are their main target. Artists and computer graphics professionals often get trapped in perpetual dependency from a company that may decide at any moment to discontinue the product if it is not profitable any longer; or it may decide to introduce updates that run only on specific platforms —most likely nonfree. So users have no choice but to keep the old version of the program or else invest in a new operating system.

Isabel Saij explains why she decided to break free from the trap by adopting Free Software:

“With proprietary programs the artist is at the mercy of the software development company. Early in 2003 I used LiveMotion to design my digital 2D and 3D works with interactive pieces. Later that year the company decided to discontinue it so I was left without support for a piece of software on which I had spent my money and my time to learn how to use it. Moreover, whenever proprietary software developers decide to introduce new functionalities, you have to buy an update which often runs on the latest versions of proprietary operating systems only. So you are stuck in a vicious circle completely helpless. It’s frustrating and there’s nothing you can do about it. With Free Software, good projects never die due to the community being able to access the code. Someone else can come along and continue developing the software.”

Results
The introduction of Free Software in the slum removed the barriers that prevented this marginalized sector of society from accessing knowledge in the field of information technology. It provided these people with the opportunity to unfold innate capabilities that would otherwise have never come to surface. This newly discovered intellectual richness brings benefit and progress not only to the involved individuals themselves and to the local community but to society as a whole, since they have learned how to overcome the detrimental effects of unjust global economic policies and are now ready for a productive life.

With Free Software, users received all the benefits of digital education without being constrained to compromise their principles. The ethical values of Free Software are in line with and sustain those principles: not only were people free to use the software as they wished, install it in as many machines as they wished, but they were encouraged to copy it and share it with their neighbors in solidarity. Mani has become an artist using GIMP and a student of Computer Science; by now, he has acquired enough knowledge to study the source code and to modify it to meet the needs of his community, if necessary. Software freedom results in redistribution of intellectual and economic wealth, which is not possible where access to knowledge is restricted.

In less disadvantaged contexts, users of GIMP have benefited from software freedom in many ways. They are no longer subject to arbitrary decisions by proprietary software companies; instead, they belong to a large and strong community where developers do care about their needs and fellow users provide additional support. Apart from the official manuals and tutorials, enthusiastic users publish lots of instructional materials and, due to the availability of the source code, those with programming skills have contributed a number of plug-ins to enhance the performance of the application.

As a free program under the GNU GPL version 3 or later, no arbitrary decision by developers can ever stop the advancement of GIMP nor can the program be made proprietary.
